{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"operationLimitRecovery.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/enhancers/operationLimitRecovery.ts"],"sourcesContent":["import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    let isOperationLimit = false\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        ;(isOperationLimit = e instanceof OperationLimitError)\n          ? addTask(data, true)\n          : observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    if (!subscription.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n        onEmptySlot()\n      })\n    } else if (!isOperationLimit) onEmptySlot()\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"file":"errors.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/errors.ts"],"sourcesContent":["export class BlockNotPinnedError extends Error {\n  constructor(hash: string, label: string) {\n    super(`Block ${hash} is not pinned (${label})`)\n    this.name = \"BlockNotPinnedError\"\n  }\n}\n"],"names":[],"mappings":";;;AAAO,MAAM,4BAA4B,KAAM,CAAA;IAC7C,WAAA,CAAY,IAAA,EAAc,KAAe,CAAA;QACvC,KAAA,CAAM,CAAS,MAAA,EAAA,IAAI,CAAmB,gBAAA,EAAA,KAAK,CAAG,CAAA,CAAA,CAAA;QAC9C,IAAA,CAAK,IAAO,GAAA,qBAAA;IAAA;AAEhB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"file":"optionalHash.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/enhancers/optionalHash.ts"],"sourcesContent":["import {\n  MonoTypeOperatorFunction,\n  Observable,\n  catchError,\n  concatMap,\n  mergeMap,\n  take,\n  throwError,\n  timer,\n} from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\n\nconst dynamicBlocks = new Set([\"best\", \"finalized\", null])\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const getWithOptionalhash$ = (\n  finalized$: Observable<string>,\n  best$: Observable<string>,\n  usingBlock: <T>(blockHash: string) => MonoTypeOperatorFunction<T>,\n) => {\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) => {\n      if (!dynamicBlocks.has(hash))\n        return operable(fn(hash as string, ...args)).pipe(\n          usingBlock(hash as string),\n        )\n\n      const hash$ = hash === \"best\" ? best$ : finalized$\n      const result$: Observable<T> = hash$.pipe(\n        take(1),\n        mergeMap((h) => fn(h, ...args).pipe(usingBlock(h))),\n        catchError((e) => {\n          return e instanceof BlockNotPinnedError\n            ? result$\n            : throwError(() => e)\n        }),\n      )\n      return operable(result$)\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAaA,MAAM,gBAAA,aAAA,GAAoB,IAAA,GAAA,CAAI;IAAC,MAAQ;IAAA,WAAA;IAAa,IAAI;CAAC,CAAA;AAEzD,MAAM,QAAA,GAAW,CAAI,OAA2B,KAAA;IAC9C,MAAM,SAAwB,OAAQ,CAAA,IAAA,EACpC,8MAAA,EAAW,CAAC,CAAA,GACV,CAAa,iSAAA,6BAAA,qMACT,QAAA,EAAM,GAAG,CAAA,CAAE,IAAK,EAAA,6MAAA,EAAU,IAAM,MAAM,CAAC,CACvC,qMAAA,aAAA,EAAW,IAAM,CAAC;IAGnB,OAAA,MAAA;AACT,CAAA;AAEO,MAAM,oBAAuB,GAAA,CAClC,UACA,EAAA,KAAA,EACA,UACG,KAAA;IACH,OAAO,CACH,EAAA,GAEF,CAAC,IAAA,EAAA,GAAwB,IAAe,KAAA;YAClC,IAAA,CAAC,aAAc,CAAA,GAAA,CAAI,IAAI,CAAA,EACzB,OAAO,SAAS,EAAG,CAAA,IAAA,EAAgB,GAAG,IAAI,CAAC,CAAE,CAAA,IAAA,CAC3C,WAAW,IAAc;YAGvB,MAAA,KAAA,GAAQ,IAAS,KAAA,MAAA,GAAS,KAAQ,GAAA,UAAA;YACxC,MAAM,UAAyB,KAAM,CAAA,IAAA,EACnC,wMAAA,EAAK,CAAC,CAAA,oMACN,WAAA,AAAS,EAAA,CAAC,CAAM,GAAA,EAAA,CAAG,CAAG,EAAA,GAAG,IAAI,CAAA,CAAE,IAAK,CAAA,UAAA,CAAW,CAAC,CAAC,CAAC,CAAA,oMAClD,aAAA,EAAW,CAAC,CAAM,KAAA;gBAChB,OAAO,CAAa,kXAAA,sBAAA,GAChB,OACA,qMAAA,aAAA,EAAW,IAAM,CAAC,CAAA;YAAA,CACvB;YAEH,OAAO,SAAS,OAAO,CAAA;QAAA,CACzB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 210, "column": 0}, "map": {"version":3,"file":"fromAbortControllerFn.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/enhancers/fromAbortControllerFn.ts"],"sourcesContent":["import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n"],"names":[],"mappings":";;;;;AAEa,MAAA,qBAAA,GACX,CACE,EAEF,GAAA,CAAA,GAAI,OACF,kMAAI,aAAA,CAAW,CAAC,QAAa,KAAA;YACvB,IAAA,OAAA,GAAuC,IAAI,eAAgB,EAAA;YAE/D,EAAA,CAAG,GAAG,CAAC;mBAAG;gBAAM,OAAQ,CAAA,MAAM;aAAC,CAAE,CAAA,IAAA,CAC/B,CAAC,KAAe,KAAA;gBACd,QAAA,CAAS,IAAA,CAAK,KAAK,CAAA;gBACnB,QAAA,CAAS,QAAS,EAAA;YAAA,CACpB,EACA,CAAC,KAAe,KAAA;gBACd,QAAA,CAAS,KAAA,CAAM,KAAK,CAAA;YAAA;YAIxB,OAAO,MAAM;gBACX,QAAA,CAAS,WAAY,EAAA;gBACrB,OAAA,CAAS,KAAM,EAAA;gBACL,OAAA,GAAA,KAAA,CAAA;YAAA,CACZ;QACF,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"file":"lazyFollower.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/enhancers/lazyFollower.ts"],"sourcesContent":["import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n"],"names":[],"mappings":";;;AAEO,MAAM,gBACX,GAAA,CAAC,WACD,GAAA,CAAmC,GACnC,GAAA,CAAA,GAAI,IACD,GAAA,WAAA,EAAsB,CAAA,GAAG,CAAE,CAAA,GAAG,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"file":"withStopRecovery.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/enhancers/withStopRecovery.ts"],"sourcesContent":["import { Observable, ObservedValueOf, Subscription } from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { PinnedBlocks } from \"../streams\"\n\nexport function withStopRecovery<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n  label: string,\n) {\n  return (hash: string, ...args: A) => {\n    const source$ = fn(hash, ...args)\n\n    return new Observable<ObservedValueOf<typeof source$>>((observer) => {\n      let sourceSub: Subscription | null = null\n      let isSubscribed = false\n      const performSourceSub = () => {\n        if (isSubscribed) return\n        isSubscribed = true\n        sourceSub = source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => observer.error(e),\n          complete: () => observer.complete(),\n        })\n        sourceSub.add(() => {\n          isSubscribed = false\n          sourceSub = null\n        })\n      }\n\n      let isRecovering = false\n      const blockSub = blocks$.subscribe({\n        next: (v) => {\n          const block = v.blocks.get(hash)\n          if (!block) {\n            // This branch used to conflict with BlockPrunedError, as the block might disappear when it gets pruned\n            // We can avoid this conflict by checking that we're actually recovering.\n            if (isRecovering) {\n              observer.error(new BlockNotPinnedError(hash, label))\n            }\n          } else if (block.recovering) {\n            // Pause while it's recovering, as we don't know if the block is there\n            sourceSub?.unsubscribe()\n          } else {\n            performSourceSub()\n          }\n          isRecovering = v.recovering\n        },\n        error: (e) => observer.error(e),\n      })\n\n      return () => {\n        blockSub.unsubscribe()\n        sourceSub?.unsubscribe()\n      }\n    })\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAIgB,SAAA,gBAAA,CACd,OACA,EAAA,EAAA,EACA,KACA,EAAA;IACO,OAAA,CAAC,MAAA,GAAiB,IAAY,KAAA;QACnC,MAAM,OAAU,GAAA,EAAA,CAAG,IAAM,EAAA,GAAG,IAAI,CAAA;QAEzB,OAAA,kMAAI,aAA4C,CAAA,CAAC,QAAa,KAAA;YACnE,IAAI,SAAiC,GAAA,IAAA;YACrC,IAAI,YAAe,GAAA,KAAA;YACnB,MAAM,mBAAmB,MAAM;gBAC7B,IAAI,YAAc,EAAA;gBACH,YAAA,GAAA,IAAA;gBACf,SAAA,GAAY,QAAQ,SAAU,CAAA;oBAC5B,IAAM,EAAA,CAAC,CAAM,GAAA,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;oBAC5B,KAAO,EAAA,CAAC,CAAM,GAAA,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA;oBAC9B,QAAA,EAAU,IAAM,QAAA,CAAS,QAAS;gBAAA,CACnC,CAAA;gBACD,SAAA,CAAU,GAAA,CAAI,MAAM;oBACH,YAAA,GAAA,KAAA;oBACH,SAAA,GAAA,IAAA;gBAAA,CACb,CAAA;YAAA,CACH;YAEA,IAAI,YAAe,GAAA,KAAA;YACb,MAAA,QAAA,GAAW,QAAQ,SAAU,CAAA;gBACjC,IAAA,EAAM,CAAC,CAAM,KAAA;oBACX,MAAM,KAAQ,GAAA,CAAA,CAAE,MAAO,CAAA,GAAA,CAAI,IAAI,CAAA;oBAC/B,IAAI,CAAC,KAAO,EAAA;wBAGV,IAAI,YAAc,EAAA;4BAChB,QAAA,CAAS,KAAM,CAAA,0WAAI,sBAAoB,CAAA,IAAA,EAAM,KAAK,CAAC,CAAA;wBAAA;oBACrD,CACF,MAAA,IAAW,MAAM,UAAY,EAAA;wBAE3B,SAAA,EAAW,WAAY,EAAA;oBAAA,CAClB,MAAA;wBACY,gBAAA,EAAA;oBAAA;oBAEnB,YAAA,GAAe,CAAE,CAAA,UAAA;gBAAA,CACnB;gBACA,KAAO,EAAA,CAAC,CAAM,GAAA,QAAA,CAAS,KAAA,CAAM,CAAC;YAAA,CAC/B,CAAA;YAED,OAAO,MAAM;gBACX,QAAA,CAAS,WAAY,EAAA;gBACrB,SAAA,EAAW,WAAY,EAAA;YAAA,CACzB;QAAA,CACD,CAAA;IAAA,CACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"file":"new-blocks.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/new-blocks.ts"],"sourcesContent":["import { mergeMap, Observable, scan, share } from \"rxjs\"\nimport { BlockInfo } from \"./chainHead\"\nimport { PinnedBlocks } from \"./streams\"\n\nexport const getNewBlocks$ = (pinnedBlocks$: Observable<PinnedBlocks>) =>\n  pinnedBlocks$.pipe(\n    scan(\n      ({ reportedBlocks: prevReportedBlocks }, { blocks }) => {\n        const reportedBlocks = new Set<string>(blocks.keys())\n        const newBlocks: BlockInfo[] = []\n\n        if (reportedBlocks.size > prevReportedBlocks.size) {\n          blocks.forEach(({ hash, number, parent }) => {\n            if (!prevReportedBlocks.has(hash)) {\n              newBlocks.push({\n                hash,\n                number,\n                parent,\n              })\n            }\n          })\n        }\n\n        return { reportedBlocks, newBlocks }\n      },\n      {\n        reportedBlocks: new Set<string>(),\n        newBlocks: new Array<BlockInfo>(0),\n      },\n    ),\n    mergeMap(({ newBlocks }) => newBlocks),\n    share(),\n  )\n"],"names":[],"mappings":";;;;;AAIa,MAAA,aAAA,GAAgB,CAAC,aAAA,GAC5B,aAAc,CAAA,IAAA,mMACZ,OAAA,EACE,CAAC,EAAE,cAAA,EAAgB,kBAAA,EAAsB,EAAA,EAAE,MAAA,EAAa,KAAA;QACtD,MAAM,cAAiB,GAAA,IAAI,GAAY,CAAA,MAAA,CAAO,IAAA,EAAM,CAAA;QACpD,MAAM,YAAyB,EAAC;QAE5B,IAAA,cAAA,CAAe,IAAO,GAAA,kBAAA,CAAmB,IAAM,EAAA;YACjD,MAAA,CAAO,OAAA,CAAQ,CAAC,EAAE,IAAM,EAAA,MAAA,EAAQ,MAAA,EAAa,KAAA;gBAC3C,IAAI,CAAC,kBAAA,CAAmB,GAAI,CAAA,IAAI,CAAG,EAAA;oBACjC,SAAA,CAAU,IAAK,CAAA;wBACb,IAAA;wBACA,MAAA;wBACA;oBAAA,CACD,CAAA;gBAAA;YACH,CACD,CAAA;QAAA;QAGI,OAAA;YAAE;YAAgB,SAAU;QAAA,CAAA;IAAA,CACrC,EACA;QACE,cAAA,EAAA,aAAA,GAAA,IAAoB,GAAY,EAAA;QAChC,SAAA,EAAW,IAAI,KAAA,CAAiB,CAAC;IAAA,sMAGrC,WAAA,AAAS,EAAA,CAAC,EAAE,SAAA,EAAA,GAAgB,SAAS,CAAA,oMACrC,QAAA,AAAM","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"file":"storage-queries.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/storage-queries.ts"],"sourcesContent":["import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            // TODO: leave it like this b/c due to a bug on\n            // PolkadotSDK sometimes this value is `undefined`\n            // https://github.com/paritytech/polkadot-sdk/issues/6683\n            if (nDiscarded > 0)\n              observer.next(\n                recoveralStorage$(\n                  hash,\n                  queries.slice(-nDiscarded),\n                  childTrie,\n                  true,\n                ),\n              )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n"],"names":[],"mappings":";;;;;AAQa,MAAA,oBAAA,GAAuB,CAClC,WAAA,EACA,YACG,KAAA;IACH,MAAM,oBAAoB,CACxB,IAAA,EACA,OACA,EAAA,SAAA,EACA,iBAEA,kMAAI,aAAA,CACF,CAAC,QACC,GAAA,WAAA,EAAc,CAAA,mBAAA,CACZ,IAAA,EACA,OAAA,EACA,SAAa,IAAA,IAAA,EACb,CAAC,KAAU,KAAA;gBACT,QAAA,CAAS,IAAA,CAAK,KAAK,CAAA;YAAA,CACrB,EACA,CAAC,KAAU,KAAA;gBACT,QAAA,CAAS,KAAA,CAAM,KAAK,CAAA;YAAA,CACtB,EACA,MAAM;gBACJ,QAAA,CAAS,QAAS,EAAA;YAAA,CACpB,EACA,CAAC,UAAe,KAAA;gBAId,IAAI,UAAa,GAAA,CAAA,EACN,QAAA,CAAA,IAAA,CACP,iBAAA,CACE,IAAA,EACA,OAAA,CAAQ,KAAM,CAAA,CAAC,UAAU,CAAA,EACzB,SAAA,EACA;YAEJ,IAGR,IAAK,mMAAA,WAAA,EAAY,GAAA,YAAA,CAAa,cAAc,CAAC,CAAA;IAE1C,OAAA,iBAAA;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"file":"follow.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/streams/follow.ts"],"sourcesContent":["import { BlockHeader, blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  BestBlockChanged,\n  ChainHead,\n  Finalized,\n  FollowEventWithRuntime,\n  FollowResponse,\n  Initialized,\n  NewBlockWithRuntime,\n  StopError,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ObservedValueOf,\n  Subscription,\n  connectable,\n  noop,\n} from \"rxjs\"\n\ntype EnhancedFollowEventWithRuntime =\n  | (Initialized & {\n      number: number\n      parentHash: string\n    })\n  | NewBlockWithRuntime\n  | BestBlockChanged\n  | Finalized\n\nconst withInitializedNumber =\n  (getHeader: (hash: string) => Promise<BlockHeader>) =>\n  (source$: Observable<FollowEventWithRuntime>) =>\n    new Observable<EnhancedFollowEventWithRuntime>((observer) => {\n      let pending: Array<EnhancedFollowEventWithRuntime> | null = null\n      return source$.subscribe({\n        next(event) {\n          if (event.type === \"initialized\") {\n            pending = []\n            getHeader(event.finalizedBlockHashes[0])\n              .then((header) => {\n                if (!observer.closed) {\n                  observer.next({\n                    ...event,\n                    number: header.number,\n                    parentHash: header.parentHash,\n                  })\n                  pending!.forEach((e) => {\n                    observer.next(e)\n                  })\n                  pending = null\n                }\n              })\n              .catch((e) => {\n                if (!observer.closed) observer.error(e)\n              })\n          } else if (pending) pending.push(event)\n          else observer.next(event)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n    })\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse | null = null\n  let unfollow: () => void = noop\n\n  const getFollower = () => {\n    if (!follower) throw new Error(\"Missing chainHead subscription\")\n    return follower\n  }\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const follow$ = connectable(\n    new Observable<FollowEventWithRuntime>((observer) => {\n      follower = chainHead(\n        true,\n        (e) => {\n          observer.next(e)\n        },\n        (e) => {\n          follower = null\n          observer.error(e)\n        },\n      )\n      unfollow = () => {\n        observer.complete()\n        follower?.unfollow()\n      }\n    }).pipe(withInitializedNumber(getHeader), retryChainHeadError()),\n  )\n\n  const startFollow = () => {\n    follow$.connect()\n    return () => {\n      unfollow()\n    }\n  }\n\n  return {\n    getHeader,\n    getFollower,\n    startFollow,\n    follow$,\n  }\n}\n\nconst retryChainHeadError =\n  <T extends { type: string }>() =>\n  (source$: Observable<T>) =>\n    new Observable<\n      | T\n      | {\n          type: \"stop-error\"\n        }\n    >((observer) => {\n      const subscription = new Subscription()\n      const subscribe = () =>\n        source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => {\n            subscription.add(subscribe())\n            if (e instanceof StopError) {\n              observer.next({ type: \"stop-error\" })\n            } else {\n              console.warn(\"ChainHead follow request failed, retrying…\", e)\n            }\n          },\n          complete: () => observer.complete(),\n        })\n      subscription.add(subscribe())\n      return subscription\n    })\n\nexport type FollowEvent =\n  | ObservedValueOf<ReturnType<ReturnType<typeof withInitializedNumber>>>\n  | { type: \"stop-error\" }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 471, "column": 0}, "map": {"version":3,"file":"get-raw-metadta.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/utils/get-raw-metadta.ts"],"sourcesContent":["import { Bytes, Option, u32, Vector } from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { catchError, map, mergeMap, Observable, of } from \"rxjs\"\n\nconst versionedArgs = (v: number) => toHex(u32.enc(v))\nconst opaqueBytes = Bytes()\nconst optionalOpaqueBytes = Option(opaqueBytes)\nconst u32ListDecoder = Vector(u32).dec\n\nexport const getRawMetadata$ = (\n  call$: (method: string, args: string) => Observable<string>,\n): Observable<Uint8Array> => {\n  const versions$ = call$(\"Metadata_metadata_versions\", \"\").pipe(\n    map(u32ListDecoder),\n    catchError(() => of([14])),\n  )\n\n  const versioned$ = (availableVersions: number[]) => {\n    const [v] = availableVersions\n      .filter((x) => x > 13 && x < 17)\n      .sort((a, b) => b - a)\n    return v === 14\n      ? call$(\"Metadata_metadata\", \"\").pipe(map(opaqueBytes.dec))\n      : call$(\"Metadata_metadata_at_version\", versionedArgs(v)).pipe(\n          map((x) => optionalOpaqueBytes.dec(x)!),\n        )\n  }\n\n  return versions$.pipe(mergeMap(versioned$))\n}\n"],"names":[],"mappings":";;;;;;;;;;AAIA,MAAM,gBAAgB,CAAC,CAAA,gPAAc,QAAA,6MAAM,MAAI,CAAA,GAAA,CAAI,CAAC,CAAC,CAAA;AACrD,MAAM,cAAc,uNAAA,AAAM,EAAA;AAC1B,MAAM,mBAAA,uSAAsB,SAAA,EAAO,WAAW,CAAA;AAC9C,MAAM,cAAA,uSAAiB,SAAA,AAAO,EAAA,iNAAG,CAAE,CAAA,GAAA;AAEtB,MAAA,eAAA,GAAkB,CAC7B,KAC2B,KAAA;IAC3B,MAAM,SAAY,GAAA,KAAA,CAAM,4BAA8B,EAAA,EAAE,CAAE,CAAA,IAAA,EACxD,uMAAA,EAAI,cAAc,CAAA,oMAClB,aAAA,EAAW,sMAAM,KAAA,EAAG;YAAC,EAAE;SAAC,CAAC;IAGrB,MAAA,UAAA,GAAa,CAAC,iBAAgC,KAAA;QAClD,MAAM,CAAC,CAAC,CAAA,GAAI,iBACT,CAAA,MAAA,CAAO,CAAC,CAAM,GAAA,CAAA,GAAI,EAAM,IAAA,CAAA,GAAI,EAAE,CAC9B,CAAA,IAAA,CAAK,CAAC,CAAG,EAAA,CAAA,GAAM,IAAI,CAAC,CAAA;QACvB,OAAO,MAAM,EACT,GAAA,KAAA,CAAM,mBAAqB,EAAA,EAAE,EAAE,IAAK,mMAAA,MAAA,EAAI,WAAY,CAAA,GAAG,CAAC,CACxD,GAAA,KAAA,CAAM,gCAAgC,aAAc,CAAA,CAAC,CAAC,CAAE,CAAA,IAAA,mMACtD,MAAA,EAAI,CAAC,CAAA,GAAM,mBAAoB,CAAA,GAAA,CAAI,CAAC,CAAE;IACxC,CACN;IAEA,OAAO,SAAU,CAAA,IAAA,mMAAK,WAAA,AAAS,EAAA,UAAU,CAAC,CAAA;AAC5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 503, "column": 0}, "map": {"version":3,"file":"create-metadata-ctx.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/utils/create-metadata-ctx.ts"],"sourcesContent":["import type { RuntimeContext } from \"@/chainHead\"\nimport {\n  AccountId,\n  Bytes,\n  compactNumber,\n  createDecoder,\n  Decoder,\n  DecoderType,\n  enhanceDecoder,\n  extrinsicFormat,\n  StringRecord,\n  Struct,\n  u16,\n  u8,\n  type UnifiedMetadata,\n} from \"@polkadot-api/substrate-bindings\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\n\nconst CHECK_MORTALITY = \"CheckMortality\"\n\nexport const createRuntimeCtx = (\n  metadata: UnifiedMetadata,\n  metadataRaw: Uint8Array,\n  codeHash: string,\n): RuntimeContext => {\n  const lookup = getLookupFn(metadata)\n  const dynamicBuilder = getDynamicBuilder(lookup)\n  const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n  const assetPayment = metadata.extrinsic.signedExtensions.find(\n    (x) => x.identifier === \"ChargeAssetTxPayment\",\n  )\n\n  let assetId: null | number = null\n  if (assetPayment) {\n    const assetTxPayment = lookup(assetPayment.type)\n    if (assetTxPayment.type === \"struct\") {\n      const optionalAssetId = assetTxPayment.value.asset_id\n      if (optionalAssetId.type === \"option\") assetId = optionalAssetId.value.id\n    }\n  }\n\n  const extrinsicDecoder = getExtrinsicDecoder(lookup.metadata, dynamicBuilder)\n  const getMortalityFromTx: typeof mortalityDecoder = (tx) => {\n    const decodedExt = extrinsicDecoder(tx)\n    return (\n      (\"extra\" in decodedExt &&\n        (decodedExt.extra[CHECK_MORTALITY] as\n          | DecoderType<typeof mortalityDecoder>\n          | undefined)) || { mortal: false }\n    )\n  }\n\n  return {\n    assetId,\n    metadataRaw,\n    codeHash,\n    lookup,\n    dynamicBuilder,\n    events: {\n      key: events.keys.enc(),\n      dec: events.value.dec as any,\n    },\n    accountId: AccountId(dynamicBuilder.ss58Prefix),\n    getMortalityFromTx,\n  }\n}\n\n// TODO: put all the logic that follows in a generic enough low-level package\nconst allBytesDec = Bytes(Infinity).dec\n\ntype DecodedExtrinsic = {\n  len: number\n  callData: Uint8Array\n} & (\n  | { version: 4 | 5; type: \"bare\" }\n  | {\n      version: 4\n      type: \"signed\"\n      address: any\n      signature: any\n      extra: Record<string, any>\n    }\n  | {\n      version: 5\n      type: \"general\"\n      extensionVersion: number\n      extra: Record<string, any>\n    }\n)\n\nconst mortalDecoder = enhanceDecoder(u16[1], (input) => {\n  const period = 2 << input % (1 << 4)\n  const factor = Math.max(period >> 12, 1)\n  const phase = (input >> 4) * factor\n  return { mortal: true as const, period, phase }\n})\n\nconst mortalityDecoder = createDecoder((value) => {\n  const firstByte = u8.dec(value)\n  if (firstByte === 0) return { mortal: false as const }\n  const secondByte = u8.dec(value)\n  return mortalDecoder(Uint8Array.from([firstByte, secondByte]))\n})\n\nconst getExtrinsicDecoder = (\n  metadata: UnifiedMetadata,\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>,\n): Decoder<DecodedExtrinsic> => {\n  const innerExtra = Object.fromEntries(\n    metadata.extrinsic.signedExtensions.map(\n      (x) =>\n        [\n          x.identifier,\n          x.identifier === CHECK_MORTALITY\n            ? mortalityDecoder\n            : dynamicBuilder.buildDefinition(x.type)[1],\n        ] as [string, Decoder<any>],\n    ),\n  ) as StringRecord<Decoder<any>>\n\n  let address: Decoder<any>\n  let signature: Decoder<any>\n  const { extrinsic } = metadata\n  if (\"address\" in extrinsic) {\n    // v15/v16\n    address = dynamicBuilder.buildDefinition(extrinsic.address)[1]\n    signature = dynamicBuilder.buildDefinition(extrinsic.signature)[1]\n  } else {\n    // v14\n    const params = metadata.lookup[extrinsic.type]?.params\n    const _call = params?.find((v) => v.name === \"Call\")?.type\n    const addr = params?.find((v) => v.name === \"Address\")?.type\n    const sig = params?.find((v) => v.name === \"Signature\")?.type\n    if (_call == null || addr == null || sig == null)\n      throw new Error(\"Call, Address and/or signature not found\")\n    address = dynamicBuilder.buildDefinition(addr)[1]\n    signature = dynamicBuilder.buildDefinition(sig)[1]\n  }\n\n  const v4Body = Struct.dec({\n    address,\n    signature,\n    extra: Struct.dec(innerExtra),\n    callData: allBytesDec,\n  })\n\n  return createDecoder((data) => {\n    const len = compactNumber.dec(data)\n    const { type, version } = extrinsicFormat[1](data)\n    if (type === \"bare\")\n      return { len, version, type, callData: allBytesDec(data) }\n    if (type === \"signed\") return { len, version, type, ...v4Body(data) }\n\n    const extensionVersion = u8.dec(data)\n    let extraDec: Decoder<StringRecord<any>>\n    if (metadata.version === 16) {\n      const extensionsToApply = (\n        metadata as UnifiedMetadata<16>\n      ).extrinsic.signedExtensionsByVersion.find(\n        ([x]) => x === extensionVersion,\n      )\n      if (!extensionsToApply) throw new Error(\"Unexpected extension version\")\n      extraDec = Struct.dec(\n        Object.fromEntries(\n          Object.entries(innerExtra).filter((_, idx) =>\n            extensionsToApply[1].includes(idx),\n          ),\n        ) as StringRecord<Decoder<any>>,\n      )\n    } else extraDec = Struct.dec(innerExtra)\n    const extra = extraDec(data)\n\n    return {\n      len,\n      type,\n      version,\n      extensionVersion,\n      extra,\n      callData: allBytesDec(data),\n    }\n  }) as any\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 639, "column": 0}, "map": {"version":3,"file":"get-runtime-creator.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/streams/get-runtime-creator.ts"],"sourcesContent":["import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  Binary,\n  Codec,\n  Decoder,\n  HexString,\n  metadata as metadataCodec,\n  SS58String,\n  UnifiedMetadata,\n  unifyMetadata,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  catchError,\n  EMPTY,\n  map,\n  mergeMap,\n  Observable,\n  of,\n  shareReplay,\n  tap,\n  timer,\n} from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { createRuntimeCtx, getRawMetadata$ } from \"@/utils\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<Binary>\n}\n\nexport type Mortality =\n  | {\n      mortal: false\n    }\n  | { mortal: true; period: number; phase: number }\n\nexport interface RuntimeContext {\n  metadataRaw: Uint8Array\n  lookup: MetadataLookup\n  codeHash: HexString\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  assetId: number | null\n  getMortalityFromTx: Decoder<Mortality>\n}\n\nexport interface Runtime {\n  at: string\n  codeHash$: Observable<string>\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst withRecovery =\n  (getHash: () => string | null) =>\n  <Args extends Array<any>, T>(\n    fn: (hash: string, ...args: Args) => Observable<T>,\n  ): ((...args: Args) => Observable<T>) => {\n    const result: (...args: Args) => Observable<T> = (...args) => {\n      const hash = getHash()\n      return hash\n        ? fn(hash, ...args).pipe(\n            catchError((e) => {\n              if (e instanceof BlockNotPinnedError) return result(...args)\n              if (e instanceof OperationInaccessibleError)\n                return timer(750).pipe(mergeMap(() => result(...args)))\n              throw e\n            }),\n          )\n        : EMPTY\n    }\n    return result\n  }\n\nexport const getRuntimeCreator = (\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  getCodeHash$: (blockHash: string) => Observable<string>,\n  getCachedMetadata: (codeHash: string) => Observable<Uint8Array | null>,\n  setCachedMetadata: (codeHash: string, metadataRaw: Uint8Array) => void,\n) => {\n  const getMetadata$ = (\n    codeHash$: Observable<string>,\n    rawMetadata$: Observable<Uint8Array>,\n  ): Observable<{\n    metadataRaw: Uint8Array\n    metadata: UnifiedMetadata\n    codeHash: string\n  }> =>\n    codeHash$.pipe(\n      mergeMap((codeHash) =>\n        getCachedMetadata(codeHash).pipe(\n          catchError(() => of(null)),\n          mergeMap((metadataRaw) =>\n            metadataRaw\n              ? of(metadataRaw)\n              : rawMetadata$.pipe(\n                  tap((raw) => {\n                    setCachedMetadata(codeHash, raw)\n                  }),\n                ),\n          ),\n          map((metadataRaw) => ({\n            codeHash,\n            metadataRaw,\n            metadata: unifyMetadata(metadataCodec.dec(metadataRaw)),\n          })),\n        ),\n      ),\n    )\n\n  return (getHash: () => string | null): Runtime => {\n    const enhancer = withRecovery(getHash)\n    const initialHash = getHash()!\n    const usages = new Set<string>([initialHash])\n    const codeHash$ = enhancer(getCodeHash$)().pipe(shareReplay(1))\n\n    const runtimeContext$: Observable<RuntimeContext> = getMetadata$(\n      codeHash$,\n      getRawMetadata$(enhancer(call$)),\n    ).pipe(\n      map(({ metadata, metadataRaw, codeHash }) =>\n        createRuntimeCtx(metadata, metadataRaw, codeHash),\n      ),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: initialHash,\n      runtime: runtimeContext$,\n      codeHash$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe({\n      error() {},\n    })\n\n    return result\n  }\n}\n"],"names":["metadataCodec"],"mappings":";;;;;;;;;;;;;;;;AAyEA,MAAM,YACJ,GAAA,CAAC,OACD,GAAA,CACE,EACuC,KAAA;QACjC,MAAA,MAAA,GAA2C,CAAA,GAAI,IAAS,KAAA;YAC5D,MAAM,OAAO,OAAQ,EAAA;YACrB,OAAO,IACH,GAAA,EAAA,CAAG,IAAM,EAAA,GAAG,IAAI,CAAE,CAAA,IAAA,KAChB,2MAAA,EAAW,CAAC,CAAM,KAAA;gBAChB,IAAI,CAAa,kXAAA,sBAAA,EAA4B,OAAA,MAAA,CAAO,GAAG,IAAI,CAAA;gBAC3D,IAAI,CAAa,iSAAA,6BAAA,EACR,WAAA,sMAAA,EAAM,GAAG,CAAA,CAAE,IAAK,mMAAA,WAAA,EAAS,IAAM,MAAO,CAAA,GAAG,IAAI,CAAC,CAAC,CAAA;gBAClD,MAAA,CAAA;YAAA,CACP,mMAEH,QAAA;QAAA,CACN;QACO,OAAA,MAAA;IACT,CAAA;AAEK,MAAM,iBAAoB,GAAA,CAC/B,KACA,EAAA,YAAA,EACA,mBACA,iBACG,KAAA;IACH,MAAM,YAAe,GAAA,CACnB,SACA,EAAA,YAAA,GAMA,SAAU,CAAA,IAAA,CACR,6MAAA,EAAS,CAAC,QAAA,GACR,iBAAkB,CAAA,QAAQ,CAAE,CAAA,IAAA,mMAC1B,aAAA,AAAW,EAAA,QAAM,mMAAA,AAAG,EAAA,IAAI,CAAC,CAAA,oMACzB,WAAA,EAAS,CAAC,WACR,GAAA,WAAA,IACI,sMAAA,AAAG,EAAA,WAAW,IACd,YAAa,CAAA,IAAA,mMACX,MAAA,EAAI,CAAC,GAAQ,KAAA;oBACX,iBAAA,CAAkB,UAAU,GAAG,CAAA;gBAAA,CAChC,uMAGT,MAAA,EAAI,CAAC,WAAiB,GAAA,CAAA;oBACpB,QAAA;oBACA,WAAA;oBACA,QAAU,GAAA,uTAAA,uSAAcA,WAAc,CAAA,GAAA,CAAI,WAAW,CAAC;gBAAA,CACtD,CAAA;IAKV,OAAO,CAAC,OAA0C,KAAA;QAC1C,MAAA,QAAA,GAAW,aAAa,OAAO,CAAA;QACrC,MAAM,cAAc,OAAQ,EAAA;QAC5B,MAAM,MAAS,GAAA,aAAA,GAAA,IAAI,GAAY,CAAA;YAAC,WAAW;SAAC,CAAA;QACtC,MAAA,SAAA,GAAY,SAAS,YAAY,CAAA,GAAI,IAAK,EAAA,+MAAA,EAAY,CAAC,CAAC,CAAA;QAE9D,MAAM,eAA8C,GAAA,YAAA,CAClD,SAAA,uXACA,kBAAA,EAAgB,QAAS,CAAA,KAAK,CAAC,GAC/B,IAAA,mMACA,MAAA,EAAI,CAAC,EAAE,QAAU,EAAA,WAAA,EAAa,QAAA,EAC5B,GAAA,4YAAA,EAAiB,QAAU,EAAA,WAAA,EAAa,QAAQ,sMAElD,cAAA,EAAY,CAAC;QAGf,MAAM,MAAkB,GAAA;YACtB,EAAI,EAAA,WAAA;YACJ,OAAS,EAAA,eAAA;YACT,SAAA;YACA,QAAA,EAAU,CAAC,KAAkB,KAAA;gBAC3B,MAAA,CAAO,GAAA,CAAI,KAAK,CAAA;gBACT,OAAA,MAAA;YAAA,CACT;YACA,YAAA,EAAc,CAAC,MAAW,KAAA;gBACjB,MAAA,CAAA,OAAA,CAAQ,CAAC,KAAU,KAAA;oBACxB,MAAA,CAAO,MAAA,CAAO,KAAK,CAAA;gBAAA,CACpB,CAAA;gBACD,OAAO,MAAO,CAAA,IAAA;YAAA,CAChB;YACA;QAAA,CACF;QACA,eAAA,CAAgB,SAAU,CAAA;YACxB,KAAQ,GAAA,EAAA;QAAC,CACV,CAAA;QAEM,OAAA,MAAA;IAAA,CACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 712, "column": 0}, "map": {"version":3,"file":"shareLatest.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/utils/shareLatest.ts"],"sourcesContent":["import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n"],"names":[],"mappings":";;;;;AAEO,MAAM,gNAAyD,QAAA,AAAM,EAAA;IAC1E,SAAW,EAAA,IAAM,kMAAI,gBAAA,CAAc,CAAC,CAAA;IACpC,YAAc,EAAA,IAAA;IACd,eAAiB,EAAA,IAAA;IACjB,mBAAqB,EAAA;AACvB,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 731, "column": 0}, "map": {"version":3,"file":"pinned-blocks.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/streams/pinned-blocks.ts"],"sourcesContent":["import { shareLatest } from \"@/utils\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  Observable,\n  Subject,\n  exhaustMap,\n  filter,\n  map,\n  merge,\n  scan,\n  timer,\n} from \"rxjs\"\nimport { withStopRecovery } from \"../enhancers\"\nimport type { FollowEvent } from \"./follow\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  unpinnable: boolean\n  refCount: number\n  recovering: boolean\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\ninterface CleanupEvent {\n  type: \"cleanup\"\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n  recovering: boolean\n}\n\nconst createRuntimeGetter = (pinned: PinnedBlocks, startAt: HexString) => {\n  return () => {\n    const runtime = pinned.runtimes[startAt]\n    if (!runtime) return pinned.blocks.has(startAt) ? startAt : null\n    const winner = [...runtime.usages].at(-1)\n    return winner ?? null\n  }\n}\n\nconst deleteBlock = (blocks: PinnedBlocks[\"blocks\"], blockHash: string) => {\n  blocks.get(blocks.get(blockHash)!.parent)?.children.delete(blockHash)\n  blocks.delete(blockHash)\n}\n\nconst deleteBlocks = (blocks: PinnedBlocks, toDelete: string[]) => {\n  toDelete.forEach((hash) => {\n    deleteBlock(blocks.blocks, hash)\n  })\n\n  Object.entries(blocks.runtimes)\n    .map(([key, value]) => ({\n      key,\n      usages: value.deleteBlocks(toDelete),\n    }))\n    .filter((x) => x.usages === 0)\n    .map((x) => x.key)\n    .forEach((unusedRuntime) => {\n      delete blocks.runtimes[unusedRuntime]\n    })\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEvent>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  getCodeHash$: (blockHash: string) => Observable<string>,\n  getCachedMetadata$: (codeHash: string) => Observable<Uint8Array | null>,\n  setCachedMetadata: (codeHash: string, metadataRaw: Uint8Array) => void,\n  blockUsage$: Subject<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n  deleteFromCache: (block: string) => void,\n) => {\n  const cleanup$ = new Subject<void>()\n  const cleanupEvt$ = cleanup$.pipe(\n    exhaustMap(() => timer(0)),\n    map(\n      (): CleanupEvent => ({\n        type: \"cleanup\" as const,\n      }),\n    ),\n  )\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    cleanupEvt$,\n    follow$,\n  ).pipe(\n    scan((acc, event) => {\n      const unpinAndDelete = (toUnpin: string[]) => {\n        deleteBlocks(acc, toUnpin)\n        onUnpin(toUnpin)\n      }\n\n      switch (event.type) {\n        case \"initialized\":\n          if (acc.recovering) {\n            const isConnected = event.finalizedBlockHashes.some((hash) =>\n              acc.blocks.has(hash),\n            )\n            if (!isConnected) {\n              acc = getInitialPinnedBlocks()\n            }\n          }\n\n          const [finalizedHash] = event.finalizedBlockHashes.slice(-1)\n          acc.finalized = acc.best = finalizedHash\n\n          const lastIdx = event.finalizedBlockHashes.length - 1\n          event.finalizedBlockHashes.forEach((hash, i) => {\n            const preexistingBlock = acc.blocks.get(hash)\n            if (preexistingBlock) {\n              preexistingBlock.recovering = false\n              preexistingBlock.unpinnable = i !== lastIdx\n            } else {\n              acc.blocks.set(hash, {\n                hash: hash,\n                parent:\n                  i === 0\n                    ? event.parentHash\n                    : event.finalizedBlockHashes[i - 1],\n                children: new Set(\n                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]],\n                ),\n                unpinnable: i !== lastIdx,\n                runtime: hash,\n                refCount: 0,\n                number: event.number + i,\n                recovering: false,\n              })\n            }\n          })\n\n          const finalizedRuntime = Object.values(acc.runtimes).find((runtime) =>\n            runtime.usages.has(finalizedHash),\n          )\n\n          acc.finalizedRuntime =\n            finalizedRuntime ??\n            (acc.runtimes[finalizedHash] = getRuntime(\n              createRuntimeGetter(acc, finalizedHash),\n            ))\n\n          return acc\n\n        case \"stop-error\":\n          for (const block of acc.blocks.values()) {\n            block.recovering = true\n          }\n          acc.recovering = true\n\n          return acc\n\n        case \"newBlock\": {\n          const { parentBlockHash: parent, blockHash: hash } = event\n          if (acc.blocks.has(hash)) {\n            acc.blocks.get(hash)!.recovering = false\n          } else {\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              unpinnable: false,\n              refCount: 0,\n              recovering: false,\n            }\n            acc.blocks.set(hash, block)\n            if (event.newRuntime) {\n              // getRuntime calls getHash immediately\n              // it assumes pinnedBlocks.runtimes[hash] is empty and pinnedBlocks.blocks.has(hash)\n              acc.runtimes[hash] = getRuntime(createRuntimeGetter(acc, hash))\n            }\n            acc.runtimes[block.runtime].addBlock(hash)\n          }\n\n          return acc\n        }\n\n        case \"bestBlockChanged\": {\n          if (acc.recovering) {\n            for (const [hash, block] of acc.blocks) {\n              if (block.recovering) {\n                deleteBlock(acc.blocks, hash)\n                deleteFromCache(hash)\n              }\n            }\n            acc.recovering = false\n          }\n          acc.best = event.bestBlockHash\n          return acc\n        }\n\n        case \"finalized\": {\n          acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n          const { blocks } = acc\n\n          // This logic is only needed because of a bug on some pretty old versions\n          // of the polkadot-sdk node. However, fixing it with an enhancer\n          // was a huge PITA. Therefore, it's more pragmatic to address it here\n          if (blocks.get(acc.best)!.number < blocks.get(acc.finalized)!.number)\n            acc.best = acc.finalized\n\n          acc.finalizedRuntime =\n            acc.runtimes[blocks.get(acc.finalized)!.runtime]\n\n          event.prunedBlockHashes.forEach((hash) => {\n            const block = acc.blocks.get(hash)\n            if (block) {\n              block.unpinnable = true\n            }\n          })\n\n          let current = blocks.get(blocks.get(acc.finalized)!.parent)\n          while (current && !current.unpinnable) {\n            current.unpinnable = true\n            current = blocks.get(current.parent)\n          }\n\n          cleanup$.next()\n\n          return acc\n        }\n        case \"cleanup\": {\n          const toUnpin = [...acc.blocks.values()]\n            .filter(({ unpinnable, refCount }) => unpinnable && !refCount)\n            .map(({ hash }) => hash)\n\n          unpinAndDelete(toUnpin)\n          return acc\n        }\n        case \"blockUsage\": {\n          if (!acc.blocks.has(event.value.hash)) return acc\n\n          const block = acc.blocks.get(event.value.hash)!\n          block.refCount += event.value.type === \"hold\" ? 1 : -1\n          if (block.refCount === 0 && !block.recovering && block.unpinnable) {\n            const toUnpin = [block.hash]\n            unpinAndDelete(toUnpin)\n          }\n          return acc\n        }\n      }\n    }, getInitialPinnedBlocks()),\n    filter((x) => !!x.finalizedRuntime.runtime),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntime = getRuntimeCreator(\n    withStopRecovery(pinnedBlocks$, call$, \"pinned-blocks\"),\n    withStopRecovery(pinnedBlocks$, getCodeHash$, \"pinned-blocks\"),\n    getCachedMetadata$,\n    setCachedMetadata,\n  )\n  return pinnedBlocks$\n}\n\nconst getInitialPinnedBlocks = (): PinnedBlocks => ({\n  best: \"\",\n  finalized: \"\",\n  runtimes: {},\n  blocks: new Map(),\n  finalizedRuntime: {} as Runtime,\n  recovering: false,\n})\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 922, "column": 0}, "map": {"version":3,"file":"track-tx.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/track-tx.ts"],"sourcesContent":["import {\n  Observable,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { HexString, ResultPayload } from \"@polkadot-api/substrate-bindings\"\n\nexport type AnalyzedBlock = {\n  hash: HexString\n  found:\n    | {\n        type: true\n        index: number\n        events: any\n      }\n    | {\n        type: false\n        validity: ResultPayload<any, any> | null // null means that the block was already present when the tx was broadcasted\n      }\n}\n\nexport const getTrackTx = (\n  blocks$: Observable<PinnedBlocks>,\n  getBody: (block: string) => Observable<string[]>, // Returns an observable that should emit just once and complete\n  getIsValid: (\n    block: string,\n    tx: string,\n  ) => Observable<ResultPayload<any, any>>, // Returns an observable that should emit just once and complete\n  getEvents: (block: string) => Observable<any>, // Returns an observable that should emit just once and complete\n) => {\n  const whileBlockPresent = <TT>(\n    hash: string,\n  ): (<T = TT>(base: Observable<T>) => Observable<T>) =>\n    takeUntil(blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))))\n\n  const analyzeBlock = (\n    hash: string,\n    tx: string,\n    alreadyPresent: boolean,\n  ): Observable<AnalyzedBlock> => {\n    if (alreadyPresent)\n      return of({ hash, found: { type: false, validity: null } })\n\n    const whilePresent = whileBlockPresent(hash)\n    return getBody(hash).pipe(\n      mergeMap((txs) => {\n        const index = txs.indexOf(tx)\n        return index > -1\n          ? whilePresent(getEvents(hash)).pipe(\n              map((events) => ({\n                hash,\n                found: {\n                  type: true as true,\n                  index,\n                  events,\n                },\n              })),\n            )\n          : getIsValid(hash, tx).pipe(\n              map((validity) => ({\n                hash,\n                found: { type: false as false, validity },\n              })),\n            )\n      }),\n      whilePresent,\n    )\n  }\n\n  const findInBranch = (\n    hash: string,\n    tx: string,\n    alreadyPresent: Set<string>,\n  ): Observable<AnalyzedBlock> =>\n    analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(\n      mergeMap((analyzed) => {\n        const { found } = analyzed\n        return found.type || found.validity?.success === false\n          ? of(analyzed)\n          : blocks$.pipe(\n              whileBlockPresent(hash),\n              mergeMap((x) => x.blocks.get(hash)!.children),\n              distinct(),\n              mergeMap((hash) => findInBranch(hash, tx, alreadyPresent)),\n            )\n      }),\n    )\n\n  return (tx: string): Observable<AnalyzedBlock> =>\n    blocks$.pipe(\n      take(1),\n      mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys()))),\n    )\n}\n"],"names":["hash"],"mappings":";;;;;AA2BO,MAAM,UAAa,GAAA,CACxB,OACA,EAAA,OAAA,EACA,YAIA,SACG,KAAA;IACH,MAAM,oBAAoB,CACxB,IAAA,qMAEA,YAAA,AAAU,EAAA,OAAA,CAAQ,IAAA,kMAAK,UAAA,AAAO,EAAA,CAAC,EAAE,MAAA,EAAA,GAAa,CAAC,MAAA,CAAO,GAAA,CAAI,IAAI,CAAC,CAAC,CAAC,CAAA;IAEnE,MAAM,YAAe,GAAA,CACnB,IACA,EAAA,EAAA,EACA,cAC8B,KAAA;QAC1B,IAAA,cAAA,EACK,OAAA,uMAAA,EAAG;YAAE,IAAA;YAAM,KAAO,EAAA;gBAAE,MAAM,KAAO;gBAAA,QAAA,EAAU,IAAK;YAAA,CAAA;QAAA,CAAG,CAAA;QAEtD,MAAA,YAAA,GAAe,kBAAkB,IAAI,CAAA;QACpC,OAAA,OAAA,CAAQ,IAAI,CAAE,CAAA,IAAA,mMACnB,WAAA,EAAS,CAAC,GAAQ,KAAA;YACV,MAAA,KAAA,GAAQ,GAAI,CAAA,OAAA,CAAQ,EAAE,CAAA;YAC5B,OAAO,QAAQ,CAAA,CACX,GAAA,YAAA,CAAa,SAAU,CAAA,IAAI,CAAC,CAAE,CAAA,IAAA,mMAC5B,MAAA,EAAI,CAAC,MAAY,GAAA,CAAA;oBACf,IAAA;oBACA,KAAO,EAAA;wBACL,IAAM,EAAA,IAAA;wBACN,KAAA;wBACA;oBAAA;gBACF,CACA,CAAA,KAEJ,UAAA,CAAW,IAAM,EAAA,EAAE,CAAE,CAAA,IAAA,CACnB,wMAAA,EAAI,CAAC,QAAc,GAAA,CAAA;oBACjB,IAAA;oBACA,KAAO,EAAA;wBAAE,IAAM,EAAA,KAAA;wBAAgB,QAAS;oBAAA;gBAAA,CACxC,CAAA;QACJ,CACL,CAAA,EACD;IACF,CACF;IAEA,MAAM,YAAe,GAAA,CACnB,IACA,EAAA,EAAA,EACA,cAEA,GAAA,YAAA,CAAa,IAAM,EAAA,EAAA,EAAI,cAAe,CAAA,GAAA,CAAI,IAAI,CAAC,CAAE,CAAA,IAAA,mMAC/C,WAAA,EAAS,CAAC,QAAa,KAAA;YACf,MAAA,EAAE,KAAA,EAAU,GAAA,QAAA;YACX,OAAA,KAAA,CAAM,IAAA,IAAQ,KAAM,CAAA,QAAA,EAAU,YAAY,KAC7C,qMAAA,KAAA,EAAG,QAAQ,CAAA,GACX,OAAQ,CAAA,IAAA,CACN,kBAAkB,IAAI,CAAA,EACtB,6MAAA,EAAS,CAAC,CAAM,GAAA,CAAA,CAAE,MAAA,CAAO,GAAI,CAAA,IAAI,EAAG,QAAQ,CAAA,GAC5C,4MAAA,AAAS,EAAA,qMACT,WAAA,EAAS,CAACA,KAAAA,GAAS,aAAaA,KAAM,EAAA,EAAA,EAAI,cAAc,CAAC;QAC3D,CACL;IAGE,OAAA,CAAC,KACN,OAAQ,CAAA,IAAA,mMACN,OAAA,EAAK,CAAC,CAAA,oMACN,WAAA,AAAS,EAAA,CAAC,CAAM,GAAA,YAAA,CAAa,EAAE,SAAW,EAAA,EAAA,EAAI,IAAI,GAAA,CAAI,CAAE,CAAA,MAAA,CAAO,IAAK,EAAC,CAAC,CAAC;AAE7E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 970, "column": 0}, "map": {"version":3,"file":"validate-tx.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/validate-tx.ts"],"sourcesContent":["import { Observable, map, withLatestFrom } from \"rxjs\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  _void,\n  createDecoder,\n  Decoder,\n  ResultPayload,\n  u8,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { RuntimeContext } from \"./streams\"\n\nconst external = new Uint8Array([2])\n\nconst getValidateTxArgs = (tx: string, hash: string) =>\n  toHex(mergeUint8([external, fromHex(tx), fromHex(hash)]))\n\nconst TaggedTransactionQueue = \"TaggedTransactionQueue\"\nconst validateTransaction = \"validate_transaction\"\n\nconst [, defaultInvalidTxDecoder] = Variant({\n  InvalidTransaction: Variant({\n    Call: _void,\n    Payment: _void,\n    Future: _void,\n    Stale: _void,\n    BadProof: _void,\n    AncientBirthBlock: _void,\n    ExhaustsResources: _void,\n    Custom: u8,\n    BadMandatory: _void,\n    MandatoryValidation: _void,\n    BadSigner: _void,\n  }),\n  UnknownTransaction: Variant({\n    CannotLookup: _void,\n    NoUnsignedValidator: _void,\n    Custom: u8,\n  }),\n})\nconst defaultValidateTxDecoder: Decoder<ResultPayload<undefined, any>> =\n  createDecoder((input) => {\n    const firstByte = u8.dec(input)\n    if (firstByte > 1)\n      throw new Error(\"Unable to decode validateTransaction result\")\n\n    if (!firstByte) return { success: true, value: undefined }\n    let value: any\n    try {\n      value = defaultInvalidTxDecoder(input)\n    } catch (_) {\n      value = {\n        type: \"UnknownInvalidTx\",\n      }\n    }\n    return { success: false, value }\n  })\n\nexport const getValidateTx =\n  (\n    call$: (\n      hash: string | null,\n      fnName: string,\n      parameters: string,\n    ) => Observable<string>,\n    getRuntimeContext: (hash: string) => Observable<RuntimeContext>,\n  ) =>\n  (blockHash: string, tx: string): Observable<ResultPayload<any, any>> => {\n    const decoder$ = getRuntimeContext(blockHash).pipe(\n      map((ctx) => {\n        try {\n          return ctx.dynamicBuilder.buildRuntimeCall(\n            TaggedTransactionQueue,\n            validateTransaction,\n          ).value[1] as Decoder<ResultPayload<any, any>>\n        } catch (_) {\n          return defaultValidateTxDecoder\n        }\n      }),\n    )\n    return call$(\n      blockHash,\n      `${TaggedTransactionQueue}_${validateTransaction}`,\n      getValidateTxArgs(tx, blockHash),\n    ).pipe(\n      withLatestFrom(decoder$),\n      map(([result, decoder]) => decoder(result)),\n    )\n  }\n"],"names":[],"mappings":";;;;;;;;;;;AAYA,MAAM,QAAW,GAAA,IAAI,UAAW,CAAA;IAAC,CAAC;CAAC,CAAA;AAEnC,MAAM,iBAAoB,GAAA,CAAC,EAAY,EAAA,IAAA,gPACrC,QAAA,EAAM,iQAAA,AAAW,EAAA;QAAC,QAAU;qPAAA,UAAA,EAAQ,EAAE,CAAG;qPAAA,UAAA,EAAQ,IAAI,CAAC;KAAC,CAAC,CAAA;AAE1D,MAAM,sBAAyB,GAAA,wBAAA;AAC/B,MAAM,mBAAsB,GAAA,sBAAA;AAE5B,MAAM,GAAG,uBAAuB,CAAA,wSAAI,UAAA,AAAQ,EAAA;IAC1C,wBAAoB,2SAAA,AAAQ,EAAA;QAC1B,IAAM,6MAAA,QAAA;QACN,OAAS,6MAAA,QAAA;QACT,MAAQ,6MAAA,QAAA;QACR,KAAO,4MAAA,SAAA;QACP,QAAU,6MAAA,QAAA;QACV,iBAAmB,6MAAA,QAAA;QACnB,iBAAmB,6MAAA,QAAA;QACnB,MAAQ,6MAAA,KAAA;QACR,YAAc,EAAA,mNAAA;QACd,mBAAqB,6MAAA,QAAA;QACrB,SAAW,6MAAA,QAAA;IAAA,CACZ,CAAA;IACD,qBAAoB,8SAAA,AAAQ,EAAA;QAC1B,YAAc,6MAAA,QAAA;QACd,mBAAqB,6MAAA,QAAA;QACrB,MAAQ,EAAA,gNAAA;IAAA,CACT;AACH,CAAC,CAAA;AACD,MAAM,wBAAA,kNACJ,gBAAA,AAAc,EAAA,CAAC,KAAU,KAAA;IACjB,MAAA,SAAA,8MAAY,KAAG,CAAA,GAAA,CAAI,KAAK,CAAA;IAC9B,IAAI,SAAY,GAAA,CAAA,EACR,MAAA,IAAI,MAAM,6CAA6C,CAAA;IAE/D,IAAI,CAAC,SAAW,EAAA,OAAO;QAAE,OAAS,EAAA,IAAA;QAAM,OAAO,KAAA,CAAU;IAAA,CAAA;IACrD,IAAA,KAAA;IACA,IAAA;QACF,KAAA,GAAQ,wBAAwB,KAAK,CAAA;IAAA,EAAA,OAC9B,CAAG,EAAA;QACF,KAAA,GAAA;YACN,IAAM,EAAA;QAAA,CACR;IAAA;IAEK,OAAA;QAAE,OAAS,EAAA,KAAA;QAAO,KAAM;IAAA,CAAA;AACjC,CAAC,CAAA;AAEI,MAAM,gBACX,CACE,KAAA,EAKA,iBAEF,GAAA,CAAC,WAAmB,EAAoD,KAAA;QAChE,MAAA,QAAA,GAAW,iBAAkB,CAAA,SAAS,CAAE,CAAA,IAAA,mMAC5C,MAAA,EAAI,CAAC,GAAQ,KAAA;YACP,IAAA;gBACF,OAAO,IAAI,cAAe,CAAA,gBAAA,CACxB,sBAAA,EACA,qBACA,KAAA,CAAM,CAAC,CAAA;YAAA,EAAA,OACF,CAAG,EAAA;gBACH,OAAA,wBAAA;YAAA;QACT,CACD;QAEI,OAAA,KAAA,CACL,SAAA,EACA,CAAA,EAAG,sBAAsB,CAAA,CAAA,EAAI,mBAAmB,CAAA,CAAA,EAChD,iBAAA,CAAkB,IAAI,SAAS,GAC/B,IAAA,mMACA,iBAAA,EAAe,QAAQ,CAAA,oMACvB,MAAA,EAAI,CAAC,CAAC,MAAA,EAAQ,OAAO,CAAM,GAAA,OAAA,CAAQ,MAAM,CAAC;IAE9C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1049, "column": 0}, "map": {"version":3,"file":"with-default-value.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/utils/with-default-value.ts"],"sourcesContent":["import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n"],"names":[],"mappings":";;;;;AAEa,MAAA,gBAAA,GACX,CAAO,YACP,GAAA,CAAC,UACC,kMAAI,aAAA,CAAW,CAAC,QAAa,KAAA;YAC3B,IAAI,SAAY,GAAA,KAAA;YAEV,MAAA,YAAA,GAAe,QAAQ,SAAU,CAAA;gBACrC,MAAK,CAAG,EAAA;oBACM,SAAA,GAAA,IAAA;oBACZ,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;gBAAA,CACjB;gBACA,OAAM,CAAG,EAAA;oBACP,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA;gBAAA,CAClB;gBACA,QAAW,GAAA;oBACT,QAAA,CAAS,QAAS,EAAA;gBAAA;YACpB,CACD,CAAA;YAED,IAAI,CAAC,SAAA,EAAoB,QAAA,CAAA,IAAA,CAAK,YAAY,CAAA;YAEnC,OAAA,YAAA;QACT,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1079, "column": 0}, "map": {"version":3,"file":"delay-unsubscription.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/utils/delay-unsubscription.ts"],"sourcesContent":["import { Observable } from \"rxjs\"\n\nexport const delayUnsubscription =\n  (ms?: number) =>\n  <T>(source: Observable<T>): Observable<T> =>\n    new Observable((observer) => {\n      const subscription = source.subscribe({\n        next(v) {\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n      const unsubscribe = () => subscription.unsubscribe()\n      return () => {\n        if (ms != null) setTimeout(unsubscribe, ms)\n        else Promise.resolve().then(unsubscribe)\n      }\n    })\n"],"names":[],"mappings":";;;;;AAEa,MAAA,mBAAA,GACX,CAAC,EACD,GAAA,CAAI,SACF,kMAAI,aAAA,CAAW,CAAC,QAAa,KAAA;YACrB,MAAA,YAAA,GAAe,OAAO,SAAU,CAAA;gBACpC,MAAK,CAAG,EAAA;oBACN,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;gBAAA,CACjB;gBACA,OAAM,CAAG,EAAA;oBACP,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA;gBAAA,CAClB;gBACA,QAAW,GAAA;oBACT,QAAA,CAAS,QAAS,EAAA;gBAAA;YACpB,CACD,CAAA;YACK,MAAA,WAAA,GAAc,IAAM,YAAA,CAAa,WAAY,EAAA;YACnD,OAAO,MAAM;gBAEE,OAAA,CAAA,OAAA,EAAU,CAAA,IAAA,CAAK,WAAW,CAAA;YAAA,CACzC;QACF,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1109, "column": 0}, "map": {"version":3,"file":"concatMapEager.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/utils/concatMapEager.ts"],"sourcesContent":["import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n\n        let isCompleted = false\n        let subscription = inner$.subscribe({\n          next(x: O) {\n            if (observerIdx === idx) {\n              observer.next(x)\n            } else {\n              results.get(idx)!.push(x)\n            }\n          },\n          complete() {\n            isCompleted = true\n            innerSubscriptions.delete(idx)\n            if (idx === observerIdx) {\n              observerIdx++\n              while (results.has(observerIdx)) {\n                results.get(observerIdx)!.forEach((x) => observer.next(x))\n                results.delete(observerIdx)\n                if (innerSubscriptions.has(observerIdx)) {\n                  break\n                }\n                observerIdx++\n              }\n            }\n            nextSubscription()\n          },\n          error(e: any) {\n            observer.error(e)\n          },\n        })\n\n        if (!isCompleted) innerSubscriptions.set(idx, subscription)\n      }\n\n      // Cover synchronous path sub => nextSubscription => no new values => if (topSubscription == null) complete()\n      topSubscription = new Subscription()\n      topSubscription.add(\n        source$.subscribe({\n          next(outterValue: I) {\n            const idx = mapperIdx++\n            queues.set(\n              idx,\n              defer(() => mapper(outterValue, idx)),\n            )\n            if (innerSubscriptions.size < concurrent) {\n              nextSubscription()\n            }\n          },\n          error(e: any) {\n            observer.error(e)\n          },\n          complete() {\n            if (innerSubscriptions.size === 0) {\n              observer.complete()\n            }\n          },\n        }),\n      )\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1199, "column": 0}, "map": {"version":3,"file":"chainHead.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/chainHead.ts"],"sourcesContent":["import { concatMapEager, delayUnsubscription, shareLatest } from \"@/utils\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  EMPTY,\n  MonoTypeOperatorFunction,\n  Observable,\n  ReplaySubject,\n  Subject,\n  defer,\n  distinctUntilChanged,\n  endWith,\n  filter,\n  identity,\n  map,\n  merge,\n  mergeAll,\n  mergeMap,\n  noop,\n  of,\n  scan,\n  share,\n  shareReplay,\n  switchMap,\n  take,\n  tap,\n} from \"rxjs\"\n\nimport { withDefaultValue } from \"@/utils\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withLazyFollower,\n  withStopRecovery,\n} from \"./enhancers\"\nimport { BlockNotPinnedError } from \"./errors\"\nimport { getNewBlocks$ } from \"./new-blocks\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport type {\n  BlockUsageEvent,\n  PinnedBlock,\n  PinnedBlocks,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport { getTrackTx } from \"./track-tx\"\nimport { getValidateTx } from \"./validate-tx\"\n\nexport type {\n  FollowEventWithRuntime,\n  PinnedBlock,\n  PinnedBlocks,\n  RuntimeContext,\n  SystemEvent,\n}\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (\n  chainHead: ChainHead,\n  getCachedMetadata: (codeHash: string) => Observable<Uint8Array | null>,\n  setCachedMetadata: (codeHash: string, metadataRaw: Uint8Array) => void,\n) => {\n  const { getFollower, startFollow, follow$, getHeader } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const holdBlock = (hash: string) => {\n    blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n    return () => {\n      setTimeout(() => {\n        blockUsage$.next({\n          type: \"blockUsage\",\n          value: { type: \"release\", hash },\n        })\n      }, 0)\n    }\n  }\n\n  const usingBlock: <T>(blockHash: string) => MonoTypeOperatorFunction<T> =\n    (blockHash: string) => (base) =>\n      new Observable((observer) => {\n        const release = holdBlock(blockHash)\n        const subscription = base.subscribe(observer)\n        subscription.add(release)\n        return subscription\n      })\n\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      fn(hash, ...args).pipe(usingBlock(hash))\n\n  const withInMemory =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n      label: string,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        let isPresent = false\n        pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {\n          isPresent = blocks.blocks.has(hash)\n        })\n\n        return isPresent\n          ? fn(hash, ...args).subscribe(observer)\n          : observer.error(new BlockNotPinnedError(hash, label))\n      })\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n    label: string,\n  ) =>\n    withInMemory(\n      withRefcount(\n        withStopRecovery(\n          pinnedBlocks$,\n          withRecoveryFn(fromAbortControllerFn(fn)),\n          `stop-${label}`,\n        ),\n      ),\n      label,\n    )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n\n  const stg = withRefcount(\n    withRecoveryFn(fromAbortControllerFn(lazyFollower(\"storage\"))),\n  )\n  const getCodeHash = (blockHash: string): Observable<HexString> =>\n    // \":code\" => \"0x3a636f6465\"\n    stg(blockHash, \"hash\", \"0x3a636f6465\", null).pipe(map((x) => x!))\n\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\")))),\n    getCodeHash,\n    getCachedMetadata,\n    setCachedMetadata,\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n    (block) => {\n      cache.delete(block)\n    },\n  )\n\n  const getRuntimeContext$ = withInMemory(\n    withRefcount((hash: string) =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n      ),\n    ),\n    \"getRuntimeCtx\",\n  )\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const hashCache = cache.get(hash) ?? new Map()\n    const cached = hashCache.get(key)\n    if (cached) return cached\n\n    cache.set(hash, hashCache)\n\n    let connector: ReplaySubject<T>\n    const result = stream.pipe(\n      share({\n        connector: () => (connector = new ReplaySubject()),\n      }),\n      tap({\n        complete() {\n          hashCache.set(key, connector)\n        },\n      }),\n      delayUnsubscription(),\n    )\n    hashCache.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    filter((x) => !x.recovering),\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    scan((acc, value) => {\n      let current = value.blocks.get(value.finalized)!\n      const result = [current]\n\n      const latest = acc.at(-1)\n      if (!latest) return result\n\n      while (current.number > latest.number + 1) {\n        current = value.blocks.get(current.parent)!\n        if (!current) break\n        result.unshift(current)\n      }\n      return result\n    }, [] as PinnedBlock[]),\n    mergeAll(),\n    map(toBlockInfo),\n    shareLatest,\n  )\n\n  const best$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.best === b.best),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    filter((x) => !x.recovering),\n    distinctUntilChanged(\n      (prev, current) =>\n        prev.finalized === current.finalized && prev.best === current.best,\n    ),\n    scan((acc, pinned) => {\n      const getBlockInfo = (hash: string) =>\n        acc.get(hash) || toBlockInfo(pinned.blocks.get(hash)!)\n\n      const best = getBlockInfo(pinned.best)\n      const finalized = getBlockInfo(pinned.finalized)\n\n      const len = best.number - finalized.number + 1\n      const result = new Array<BlockInfo>(len)\n      for (let i = 0, hash = best.hash; i < len; i++) {\n        result[i] = getBlockInfo(hash)\n        hash = result[i].parent\n      }\n\n      return new Map(result.map((b) => [b.hash, b]))\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.lookup.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((b) => b.hash)),\n    best$.pipe(map((b) => b.hash)),\n    usingBlock,\n  )\n\n  const _body$ = commonEnhancer(lazyFollower(\"body\"), \"body\")\n  const body$ = (hash: string) => upsertCachedStream(hash, \"body\", _body$(hash))\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"), \"storage\")\n\n  const storage$ = withOptionalHash$(\n    withInMemory(\n      <\n        Type extends StorageItemInput[\"type\"],\n        M extends\n          | undefined\n          | ((data: StorageResult<Type>, ctx: RuntimeContext) => any),\n      >(\n        hash: string,\n        type: Type,\n        keyMapper: (ctx: RuntimeContext) => string,\n        childTrie: string | null = null,\n        mapper?: M,\n      ): Observable<\n        undefined extends M ? StorageResult<Type> : ReturnType<NonNullable<M>>\n      > =>\n        pinnedBlocks$.pipe(\n          take(1),\n          mergeMap(\n            (pinned) =>\n              pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n          ),\n          mergeMap((ctx) => {\n            const key = keyMapper(ctx)\n            return upsertCachedStream(\n              hash,\n              `storage-${type}-${key}-${childTrie ?? \"\"}`,\n              _storage$(hash, type, key, childTrie),\n            ).pipe(mapper ? map((raw) => mapper(raw, ctx)) : identity)\n          }),\n        ) as Observable<\n          undefined extends M ? StorageResult<Type> : ReturnType<NonNullable<M>>\n        >,\n      \"storage\",\n    ),\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOptionalHash$(\n    withInMemory(\n      withStopRecovery(\n        pinnedBlocks$,\n        (hash: string, queries: Array<StorageItemInput>, childTrie?: string) =>\n          recoveralStorage$(hash, queries, childTrie ?? null, false),\n        `storageQueries`,\n      ),\n      \"storageQueries\",\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withInMemory(\n      withStopRecovery(\n        pinnedBlocks$,\n        (hash: string) => defer(() => getHeader(hash)),\n        \"header\",\n      ),\n      \"header\",\n    ),\n  )\n\n  const eventsAt$ = (hash: string | null) =>\n    storage$(\n      hash,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    )\n\n  const __call$ = commonEnhancer(lazyFollower(\"call\"), \"call\")\n  const call$ = withOptionalHash$((hash: string, fn: string, args: string) =>\n    upsertCachedStream(hash, `call-${fn}-${args}`, __call$(hash, fn, args)),\n  )\n\n  const validateTx$ = getValidateTx(call$, getRuntimeContext$)\n\n  const innerBody$ = (hash: string) =>\n    upsertCachedStream(hash, \"body\", _body$(hash))\n\n  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$)\n  const trackTxWithoutEvents$ = getTrackTx(\n    pinnedBlocks$,\n    innerBody$,\n    validateTx$,\n    () => of(),\n  )\n\n  const genesis$ = runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    mergeMap((runtime) => {\n      const { enc } = runtime.dynamicBuilder.buildStorage(\n        \"System\",\n        \"BlockHash\",\n      ).keys\n      // const genesis$ =\n      // there are chains (e.g. kilt) that use u64 as block number\n      // u64 is encoded as bigint\n      // using dynamic builder for safety\n      let key: string\n      try {\n        // for u32\n        key = enc(0)\n      } catch {\n        // for u64\n        key = enc(0n)\n      }\n\n      return storage$(null, \"value\", () => key, null) as Observable<HexString>\n    }),\n    shareReplay(1),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe({\n    error() {},\n  })\n\n  let unfollow = noop\n  let started: boolean | null = false\n  let nSubscribers: number = 0\n  const start = (_nSubscribers: number) => {\n    nSubscribers += _nSubscribers\n    started = true\n\n    unfollow = startFollow()\n  }\n\n  const getRuntime$ = (codeHash: string): Observable<RuntimeContext | null> =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(({ runtimes }) =>\n        merge(\n          ...Object.values(runtimes).map((runtime) =>\n            runtime.codeHash$.pipe(\n              mergeMap((_codehash) =>\n                codeHash === _codehash ? runtime.runtime : EMPTY,\n              ),\n            ),\n          ),\n        ).pipe(endWith(null), take(1)),\n      ),\n    )\n\n  return [\n    {\n      follow$,\n      finalized$,\n      best$,\n      bestBlocks$,\n      newBlocks$: getNewBlocks$(pinnedBlocks$),\n      runtime$,\n      metadata$,\n      genesis$,\n      getRuntime$,\n\n      header$,\n      body$,\n      call$,\n      storage$,\n      storageQueries$,\n      eventsAt$,\n\n      holdBlock,\n      trackTx$,\n      trackTxWithoutEvents$,\n      validateTx$,\n      pinnedBlocks$,\n      withRuntime,\n      getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n      unfollow: () => {\n        if (started == null) return\n        nSubscribers--\n        if (started && !nSubscribers) {\n          started = null\n          unfollow()\n          unfollow = noop\n        }\n      },\n    },\n    start,\n  ] as const\n}\n\nexport type ChainHead$ = ReturnType<typeof getChainHead$>[0]\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1440, "column": 0}, "map": {"version":3,"file":"tx.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/tx.ts"],"sourcesContent":["import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<never>((observer) =>\n      baseTransaction(transaction, (e) => {\n        observer.error(e)\n      }),\n    )\n"],"names":[],"mappings":";;;;;AAGA,IAAA,kBAAe,CAAC,eAAA,GACd,CAAC,WAAA,GACC,kMAAI,aAAA,CAAkB,CAAC,QAAA,GACrB,eAAgB,CAAA,WAAA,EAAa,CAAC,CAAM,KAAA;gBAClC,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA;YAAA,CACjB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1456, "column": 0}, "map": {"version":3,"file":"archive.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/archive/archive.ts"],"sourcesContent":["import { RuntimeContext } from \"@/chainHead\"\nimport { fromAbortControllerFn } from \"@/chainHead/enhancers\"\nimport { createRuntimeCtx, getRawMetadata$ } from \"@/utils\"\nimport {\n  HexString,\n  unifyMetadata,\n  metadata as metadataCodec,\n  blockHeader,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  Archive,\n  StorageItemInput,\n  StorageItemResponse,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport { catchError, map, mergeMap, Observable, of, tap } from \"rxjs\"\n\nexport const getArchive =\n  ({ storageSubscription, ...archive }: Archive) =>\n  (getRuntime: (codeHash: string) => Observable<RuntimeContext | null>) => {\n    const runtimes: Record<string, RuntimeContext> = {}\n    const rawStorage$ = fromAbortControllerFn(archive.storage)\n    const call$ = fromAbortControllerFn(archive.call)\n    const rawHeader$ = fromAbortControllerFn(archive.header)\n    const body$ = fromAbortControllerFn(archive.body)\n\n    const header$ = (blockHash: string) =>\n      rawHeader$(blockHash).pipe(map(blockHeader[1]))\n\n    const getCodeHash = (blockHash: string): Observable<HexString> =>\n      // \":code\" => \"0x3a636f6465\"\n      rawStorage$(blockHash, \"hash\", \"0x3a636f6465\", null).pipe(map((x) => x!))\n\n    const getRuntime$ = (codeHash: string, blockHash: string) =>\n      getRuntime(codeHash).pipe(\n        catchError(() => of(null)),\n        mergeMap((result) =>\n          result\n            ? of(result)\n            : getRawMetadata$((...args) => call$(blockHash, ...args)).pipe(\n                map((rawMetadata) =>\n                  createRuntimeCtx(\n                    unifyMetadata(metadataCodec.dec(rawMetadata)),\n                    rawMetadata,\n                    codeHash,\n                  ),\n                ),\n              ),\n        ),\n        tap((runtime) => {\n          runtimes[codeHash] = runtime\n        }),\n      )\n\n    const getRuntimeContext$ = (blockHash: string) =>\n      getCodeHash(blockHash).pipe(\n        mergeMap((codeHash) => {\n          const runtime = runtimes[codeHash]\n          return runtime ? of(runtime) : getRuntime$(codeHash, blockHash)\n        }),\n      )\n\n    const storage$ = <\n      Type extends StorageItemInput[\"type\"],\n      M extends\n        | undefined\n        | ((data: StorageResult<Type>, ctx: RuntimeContext) => any),\n    >(\n      hash: string,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: M,\n    ): Observable<\n      undefined extends M ? StorageResult<Type> : ReturnType<NonNullable<M>>\n    > =>\n      getRuntimeContext$(hash).pipe(\n        mergeMap((ctx) =>\n          rawStorage$(hash, type, keyMapper(ctx), childTrie).pipe(\n            map((x) => (mapper ? mapper(x, ctx) : x)),\n          ),\n        ),\n      )\n\n    const storageQueries$ = (\n      hash: string,\n      queries: Array<StorageItemInput>,\n      childTrie?: string,\n    ): Observable<StorageItemResponse> =>\n      new Observable((observer) =>\n        storageSubscription(\n          hash,\n          queries,\n          childTrie || null,\n          (item) => observer.next(item),\n          (error) => observer.error(error),\n          () => {\n            observer.complete()\n          },\n        ),\n      )\n\n    const eventsAt$ = (hash: string) =>\n      storage$(\n        hash,\n        \"value\",\n        (ctx) => ctx.events.key,\n        null,\n        (x, ctx) => ctx.events.dec(x!),\n      )\n\n    return {\n      body$,\n      header$,\n      storage$,\n      storageQueries$,\n      call$,\n      eventsAt$,\n      getRuntimeContext$,\n    }\n  }\n\nexport type Archive$ = ReturnType<ReturnType<typeof getArchive>>\n"],"names":["metadataCodec"],"mappings":";;;;;;;;;;;;;;;;AAiBa,MAAA,UAAA,GACX,CAAC,EAAE,mBAAA,EAAqB,GAAG,OAAQ,EAAA,GACnC,CAAC,UAAwE,KAAA;QACvE,MAAM,WAA2C,CAAA,CAAC;QAC5C,MAAA,WAAA,yYAAc,wBAAA,AAAsB,EAAA,OAAA,CAAQ,OAAO,CAAA;QACnD,MAAA,KAAA,yYAAQ,wBAAA,AAAsB,EAAA,OAAA,CAAQ,IAAI,CAAA;QAC1C,MAAA,UAAA,yYAAa,wBAAA,AAAsB,EAAA,OAAA,CAAQ,MAAM,CAAA;QACjD,MAAA,KAAA,GAAQ,8ZAAA,AAAsB,EAAA,OAAA,CAAQ,IAAI,CAAA;QAE1C,MAAA,OAAA,GAAU,CAAC,SAAA,GACf,UAAW,CAAA,SAAS,CAAE,CAAA,IAAA,mMAAK,MAAA,AAAI,EAAA,0SAAA,CAAY,CAAC,CAAC,CAAC,CAAA;QAEhD,MAAM,cAAc,CAAC,SAAA,GAAA,4BAAA;YAEnB,WAAA,CAAY,SAAW,EAAA,MAAA,EAAQ,cAAgB,EAAA,IAAI,CAAE,CAAA,IAAA,mMAAK,MAAA,AAAI,EAAA,CAAC,CAAM,GAAA,CAAE,CAAC;QAE1E,MAAM,cAAc,CAAC,QAAA,EAAkB,SACrC,GAAA,UAAA,CAAW,QAAQ,CAAE,CAAA,IAAA,mMACnB,aAAA,AAAW,EAAA,sMAAM,KAAA,AAAG,EAAA,IAAI,CAAC,CAAA,MACzB,yMAAA,EAAS,CAAC,MAAA,GACR,MACI,qMAAA,KAAA,EAAG,MAAM,CACT,wXAAA,kBAAA,EAAgB,CAAI,GAAA,IAAA,GAAS,KAAM,CAAA,SAAA,EAAW,GAAG,IAAI,CAAC,CAAE,CAAA,IAAA,mMACtD,MAAA,EAAI,CAAC,WACH,IAAA,2YAAA,0SACE,gBAAA,AAAc,uSAAAA,WAAA,CAAc,GAAI,CAAA,WAAW,CAAC,CAAA,EAC5C,WAAA,EACA,eAKZ,uMAAA,EAAI,CAAC,OAAY,KAAA;gBACf,QAAA,CAAS,QAAQ,CAAI,GAAA,OAAA;YAAA,CACtB;QAGL,MAAM,kBAAqB,GAAA,CAAC,SAC1B,GAAA,WAAA,CAAY,SAAS,CAAE,CAAA,IAAA,KACrB,yMAAA,EAAS,CAAC,QAAa,KAAA;gBACf,MAAA,OAAA,GAAU,QAAA,CAAS,QAAQ,CAAA;gBACjC,OAAO,4MAAU,KAAA,AAAG,EAAA,OAAO,CAAI,GAAA,WAAA,CAAY,UAAU,SAAS,CAAA;YAAA,CAC/D;QAGC,MAAA,QAAA,GAAW,CAMf,IAAA,EACA,IACA,EAAA,SAAA,EACA,YAA2B,IAC3B,EAAA,MAAA,GAIA,kBAAmB,CAAA,IAAI,CAAE,CAAA,IAAA,mMACvB,WAAA,EAAS,CAAC,MACR,WAAY,CAAA,IAAA,EAAM,MAAM,SAAU,CAAA,GAAG,CAAG,EAAA,SAAS,CAAE,CAAA,IAAA,mMACjD,MAAA,EAAI,CAAC,CAAO,GAAA,MAAA,GAAS,OAAO,CAAG,EAAA,GAAG,IAAI,CAAE;QAKhD,MAAM,eAAkB,GAAA,CACtB,IACA,EAAA,OAAA,EACA,YAEA,kMAAI,aAAA,CAAW,CAAC,QACd,GAAA,mBAAA,CACE,IAAA,EACA,OAAA,EACA,SAAa,IAAA,IAAA,EACb,CAAC,IAAA,GAAS,QAAS,CAAA,IAAA,CAAK,IAAI,CAAA,EAC5B,CAAC,KAAA,GAAU,QAAS,CAAA,KAAA,CAAM,KAAK,CAAA,EAC/B,MAAM;oBACJ,QAAA,CAAS,QAAS,EAAA;gBAAA;QAKpB,MAAA,SAAA,GAAY,CAAC,IACjB,GAAA,QAAA,CACE,IAAA,EACA,OAAA,EACA,CAAC,GAAQ,GAAA,GAAA,CAAI,MAAO,CAAA,GAAA,EACpB,IAAA,EACA,CAAC,CAAG,EAAA,GAAA,GAAQ,GAAI,CAAA,MAAA,CAAO,GAAA,CAAI,CAAE;QAG1B,OAAA;YACL,KAAA;YACA,OAAA;YACA,QAAA;YACA,eAAA;YACA,KAAA;YACA,SAAA;YACA;QAAA,CACF;IACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1511, "column": 0}, "map": {"version":3,"file":"getObservableClient.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/getObservableClient.ts"],"sourcesContent":["import {\n  type SubstrateClient,\n  type UnsubscribeFn,\n} from \"@polkadot-api/substrate-client\"\nimport { noop, Observable, of } from \"rxjs\"\nimport { ChainHead$, getChainHead$, RuntimeContext } from \"./chainHead\"\nimport getBroadcastTx$ from \"./tx\"\nimport { Archive$, getArchive } from \"./archive\"\n\nconst ofNullFn = () => of(null)\n\nexport interface ObservableClient {\n  chainHead$: (nSubscribers?: number) => ChainHead$\n  archive: (\n    getRuntime: (codeHash: string) => Observable<RuntimeContext | null>,\n  ) => Archive$\n  broadcastTx$: (transaction: string) => Observable<never>\n  destroy: UnsubscribeFn\n}\n\nconst clientCache = new Map<\n  SubstrateClient,\n  { client: ObservableClient; refCount: number }\n>()\n\nexport const getObservableClient = (\n  substrateClient: SubstrateClient,\n  cache: Partial<{\n    getMetadata: (codeHash: string) => Observable<Uint8Array | null>\n    setMetadata: (codeHash: string, rawMetadata: Uint8Array) => void\n  }> = {},\n): ObservableClient => {\n  const { getMetadata, setMetadata } = cache\n  const cached = clientCache.get(substrateClient)\n  if (cached) {\n    cached.refCount++\n    return cached.client\n  }\n\n  const destroy = () => {\n    const cached = clientCache.get(substrateClient)\n    if (!cached || cached.refCount <= 1) {\n      clientCache.delete(substrateClient)\n      substrateClient.destroy()\n    } else {\n      cached.refCount--\n    }\n  }\n\n  let cachedChainhead:\n    | readonly [ChainHead$, (nSubscribers: number) => void]\n    | null = null\n  let currentSubscribers = 0\n  let expectedSubscribers: null | number = null\n\n  const client: ObservableClient = {\n    chainHead$: (_expectedSubscribers) => {\n      currentSubscribers++\n      expectedSubscribers ||= _expectedSubscribers || 1\n      cachedChainhead ||= getChainHead$(\n        substrateClient.chainHead,\n        getMetadata || ofNullFn,\n        setMetadata || noop,\n      )\n      const [result, start] = cachedChainhead\n      if (expectedSubscribers === currentSubscribers) {\n        const copiedCurrentSubscribers = currentSubscribers\n        currentSubscribers = 0\n        expectedSubscribers = null\n        cachedChainhead = null\n        start(copiedCurrentSubscribers)\n      }\n      return result\n    },\n    archive: getArchive(substrateClient.archive),\n    broadcastTx$: getBroadcastTx$(substrateClient.transaction),\n    destroy,\n  }\n\n  clientCache.set(substrateClient, { client, refCount: 1 })\n  return client\n}\n"],"names":["cached"],"mappings":";;;;;;;;;;;AASA,MAAM,QAAA,GAAW,sMAAM,KAAA,EAAG,IAAI,CAAA;AAW9B,MAAM,WAAA,GAAA,aAAA,GAAA,IAAkB,GAGtB,EAAA;AAEK,MAAM,mBAAsB,GAAA,CACjC,eACA,EAAA,KAAA,GAGK,CAAA,CACgB,KAAA;IACf,MAAA,EAAE,WAAa,EAAA,WAAA,EAAgB,GAAA,KAAA;IAC/B,MAAA,MAAA,GAAS,WAAY,CAAA,GAAA,CAAI,eAAe,CAAA;IAC9C,IAAI,MAAQ,EAAA;QACH,MAAA,CAAA,QAAA,EAAA;QACP,OAAO,MAAO,CAAA,MAAA;IAAA;IAGhB,MAAM,UAAU,MAAM;QACdA,MAAAA,OAAAA,GAAS,WAAY,CAAA,GAAA,CAAI,eAAe,CAAA;QAC9C,IAAI,CAACA,OAAAA,IAAUA,OAAO,CAAA,QAAA,IAAY,CAAG,EAAA;YACnC,WAAA,CAAY,MAAA,CAAO,eAAe,CAAA;YAClC,eAAA,CAAgB,OAAQ,EAAA;QAAA,CACnB,MAAA;YACLA,OAAO,CAAA,QAAA,EAAA;QAAA;IACT,CACF;IAEA,IAAI,eAEO,GAAA,IAAA;IACX,IAAI,kBAAqB,GAAA,CAAA;IACzB,IAAI,mBAAqC,GAAA,IAAA;IAEzC,MAAM,MAA2B,GAAA;QAC/B,UAAA,EAAY,CAAC,oBAAyB,KAAA;YACpC,kBAAA,EAAA;YACA,mBAAA,IAAA,CAAA,mBAAA,GAAwB,oBAAwB,IAAA,CAAA,CAAA;YAC5B,eAAA,IAAA,CAAA,eAAA,gXAAA,gBAAA,EAClB,eAAgB,CAAA,SAAA,EAChB,WAAe,IAAA,QAAA,EACf,WAAe,kMAAA,OAAA,CACjB,CAAA;YACM,MAAA,CAAC,MAAQ,EAAA,KAAK,CAAI,GAAA,eAAA;YACxB,IAAI,wBAAwB,kBAAoB,EAAA;gBAC9C,MAAM,wBAA2B,GAAA,kBAAA;gBACZ,kBAAA,GAAA,CAAA;gBACC,mBAAA,GAAA,IAAA;gBACJ,eAAA,GAAA,IAAA;gBAClB,KAAA,CAAM,wBAAwB,CAAA;YAAA;YAEzB,OAAA,MAAA;QAAA,CACT;QACA,OAAA,2WAAS,aAAA,AAAW,EAAA,eAAA,CAAgB,OAAO,CAAA;QAC3C,YAAA,2VAAc,UAAA,AAAgB,EAAA,eAAA,CAAgB,WAAW,CAAA;QACzD;IAAA,CACF;IAEA,WAAA,CAAY,GAAA,CAAI,eAAiB,EAAA;QAAE,MAAQ;QAAA,QAAA,EAAU;IAAA,CAAG,CAAA;IACjD,OAAA,MAAA;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1576, "column": 0}, "map": {"version":3,"file":"with-archive.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/utils/with-archive.ts"],"sourcesContent":["import { BlockNotPinnedError } from \"@/chainHead\"\nimport { catchError, Observable } from \"rxjs\"\n\nexport const withArchive =\n  <Args extends Array<any>, T, Hash extends string | (string | null)>(\n    chainHeadFn: (blockHash: Hash, ...args: Args) => Observable<T>,\n    archiveFn: (blockHash: string, ...args: Args) => Observable<T>,\n  ): ((blockHash: Hash, ...args: Args) => Observable<T>) =>\n  (blokHash, ...args) =>\n    chainHeadFn(blokHash, ...args).pipe(\n      catchError((e) => {\n        if (!(e instanceof BlockNotPinnedError)) throw e\n\n        return archiveFn(blokHash as string, ...args).pipe(\n          catchError((actualErr) => {\n            console.warn(actualErr)\n            throw e\n          }),\n        )\n      }),\n    )\n"],"names":[],"mappings":";;;;;;;;;;AAGa,MAAA,WAAA,GACX,CACE,WAAA,EACA,SAEF,GAAA,CAAC,QAAa,EAAA,GAAA,IAAA,GACZ,WAAY,CAAA,QAAA,EAAU,GAAG,IAAI,CAAE,CAAA,IAAA,mMAC7B,aAAA,EAAW,CAAC,CAAM,KAAA;YACZ,IAAA,CAAA,CAAE,CAAa,kXAAA,sBAAA,CAAA,EAA4B,MAAA,CAAA;YAE/C,OAAO,SAAU,CAAA,QAAA,EAAoB,GAAG,IAAI,CAAE,CAAA,IAAA,mMAC5C,aAAA,EAAW,CAAC,SAAc,KAAA;gBACxB,OAAA,CAAQ,IAAA,CAAK,SAAS,CAAA;gBAChB,MAAA,CAAA;YAAA,CACP;QACH,CACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1601, "column": 0}, "map": {"version":3,"file":"block-operations.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/%40polkadot-api%2Bobservable-client%400.13.0_%40polkadot-api%2Bsubstrate-client%400.4.1_rxjs%407.8.2/node_modules/%40polkadot-api/observable-client/src/chainHead/streams/block-operations.ts"],"sourcesContent":["import { Observable, distinctUntilChanged, map, takeWhile } from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isBestOrFinalizedBlock = (\n  blocks$: Observable<PinnedBlocks>,\n  blockHash: string,\n) =>\n  blocks$.pipe(\n    takeWhile((b) => b.blocks.has(blockHash)),\n    distinctUntilChanged(\n      (a, b) => a.finalized === b.finalized && a.best === b.best,\n    ),\n    map((pinned): \"best\" | \"finalized\" | null => {\n      if (\n        pinned.blocks.get(blockHash)!.number >\n        pinned.blocks.get(pinned.best)!.number\n      )\n        return null\n\n      const { number } = pinned.blocks.get(blockHash)!\n      let current = pinned.blocks.get(pinned.best)!\n      let isFinalized = pinned.finalized === current.hash\n      while (current.number > number) {\n        current = pinned.blocks.get(current.parent)!\n        isFinalized = isFinalized || pinned.finalized === current.hash\n      }\n      if (isFinalized) return \"finalized\"\n      return current.hash === blockHash ? \"best\" : null\n    }),\n    distinctUntilChanged(),\n    takeWhile((x) => x !== \"finalized\", true),\n  )\n"],"names":[],"mappings":";;;;;AAGO,MAAM,sBAAyB,GAAA,CACpC,OACA,EAAA,SAAA,GAEA,OAAQ,CAAA,IAAA,mMACN,YAAA,EAAU,CAAC,CAAA,GAAM,EAAE,MAAO,CAAA,GAAA,CAAI,SAAS,CAAC,CAAA,EACxC,yNAAA,EACE,CAAC,GAAG,CAAM,GAAA,CAAA,CAAE,SAAA,KAAc,CAAE,CAAA,SAAA,IAAa,CAAE,CAAA,IAAA,KAAS,CAAE,CAAA,IAAA,IAExD,uMAAA,EAAI,CAAC,MAAwC,KAAA;QAEzC,IAAA,MAAA,CAAO,MAAO,CAAA,GAAA,CAAI,SAAS,CAAA,CAAG,MAC9B,GAAA,MAAA,CAAO,MAAO,CAAA,GAAA,CAAI,MAAO,CAAA,IAAI,CAAG,CAAA,MAAA,EAEzB,OAAA,IAAA;QAET,MAAM,EAAE,MAAO,EAAA,GAAI,MAAO,CAAA,MAAA,CAAO,GAAA,CAAI,SAAS,CAAA;QAC9C,IAAI,OAAU,GAAA,MAAA,CAAO,MAAO,CAAA,GAAA,CAAI,OAAO,IAAI,CAAA;QACvC,IAAA,WAAA,GAAc,MAAO,CAAA,SAAA,KAAc,OAAQ,CAAA,IAAA;QACxC,MAAA,OAAA,CAAQ,MAAA,GAAS,MAAQ,CAAA;YAC9B,OAAA,GAAU,MAAO,CAAA,MAAA,CAAO,GAAI,CAAA,OAAA,CAAQ,MAAM,CAAA;YAC5B,WAAA,GAAA,WAAA,IAAe,MAAO,CAAA,SAAA,KAAc,OAAQ,CAAA,IAAA;QAAA;QAE5D,IAAI,aAAoB,OAAA,WAAA;QACjB,OAAA,OAAA,CAAQ,IAAS,KAAA,SAAA,GAAY,MAAS,GAAA,IAAA;IAAA,CAC9C,CAAA,oMACD,uBAAA,AAAqB,EAAA,qMACrB,YAAA,AAAU,EAAA,CAAC,CAAM,GAAA,CAAA,KAAM,aAAa,IAAI","ignoreList":[0],"debugId":null}}]
}