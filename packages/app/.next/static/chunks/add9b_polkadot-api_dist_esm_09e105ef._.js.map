{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"compatibility.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/compatibility.ts"],"sourcesContent":["import { MetadataLookup } from \"@polkadot-api/metadata-builders\"\nimport {\n  CompatibilityCache,\n  CompatibilityLevel,\n  EntryPoint,\n  EntryPointCodec,\n  TypedefCodec,\n  TypedefNode,\n  entryPointsAreCompatible,\n  mapLookupToTypedef,\n  valueIsCompatibleWithDest,\n} from \"@polkadot-api/metadata-compatibility\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { Tuple, Vector } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, combineLatest, filter, firstValueFrom, map } from \"rxjs\"\nimport { ChainDefinition } from \"./descriptors\"\n\nexport class RuntimeToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _runtime(value: D) {}\n}\n\nexport class CompatibilityToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _compatibility(value: D) {}\n}\n\ninterface RuntimeTokenApi {\n  runtime: () => RuntimeContext\n}\ninterface CompatibilityTokenApi extends RuntimeTokenApi {\n  typedefNodes: TypedefNode[]\n  getEntryPoint: (opType: OpType, pallet: string, name: string) => EntryPoint\n}\nconst compatibilityTokenApi = new WeakMap<\n  CompatibilityToken,\n  CompatibilityTokenApi\n>()\nconst runtimeTokenApi = new WeakMap<RuntimeToken, RuntimeTokenApi>()\nexport const getCompatibilityApi = (\n  token: RuntimeToken | CompatibilityToken,\n): RuntimeTokenApi | CompatibilityTokenApi =>\n  token instanceof RuntimeToken\n    ? runtimeTokenApi.get(token)!\n    : compatibilityTokenApi.get(token)!\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Const = \"constants\",\n  ViewFns = \"viewFns\",\n  Api = \"apis\",\n}\n\nconst EntryPointsCodec = Vector(EntryPointCodec)\nconst TypedefsCodec = Vector(TypedefCodec)\nconst TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec)\n\nexport const createCompatibilityToken = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ChainHead$,\n): Promise<CompatibilityToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = Promise.all([\n    chainDefinition.metadataTypes.then(TypesCodec.dec),\n    chainDefinition.descriptors,\n    awaitedRuntime,\n  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {\n    const token = new (CompatibilityToken as any)()\n    compatibilityTokenApi.set(token, {\n      runtime,\n      getEntryPoint(opType, pallet, name) {\n        const idx = descriptors[opType]?.[pallet]?.[name]\n        if (idx == null)\n          throw new Error(\n            `Descriptor for ${opType} ${pallet}.${name} does not exist`,\n          )\n        return entryPoints[idx]\n      },\n      typedefNodes,\n    })\n\n    return token\n  })\n\n  return promise\n}\n\nexport const createRuntimeToken = <D>(\n  chainHead: ChainHead$,\n): Promise<RuntimeToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = awaitedRuntime.then((runtime) => {\n    const token = new (RuntimeToken as any)()\n    runtimeTokenApi.set(token, {\n      runtime,\n    })\n    return token\n  })\n\n  return promise\n}\n\n// metadataRaw -> cache\nconst metadataCache = new WeakMap<\n  Uint8Array,\n  {\n    compat: CompatibilityCache\n    lookup: MetadataLookup\n    typeNodes: (TypedefNode | null)[]\n  }\n>()\nconst getMetadataCache = (ctx: RuntimeContext) => {\n  if (!metadataCache.has(ctx.metadataRaw)) {\n    metadataCache.set(ctx.metadataRaw, {\n      compat: new Map(),\n      lookup: ctx.lookup,\n      typeNodes: [],\n    })\n  }\n  return metadataCache.get(ctx.metadataRaw)!\n}\nexport const compatibilityHelper = (\n  descriptors: Promise<RuntimeToken | CompatibilityToken>,\n  getDescriptorEntryPoint: (descriptorApi: CompatibilityTokenApi) => EntryPoint,\n  getRuntimeEntryPoint: (ctx: RuntimeContext) => EntryPoint | null,\n) => {\n  const getRuntimeTypedef = (ctx: RuntimeContext, id: number) => {\n    const cache = getMetadataCache(ctx)\n    return (cache.typeNodes[id] ||= mapLookupToTypedef(cache.lookup(id)))\n  }\n\n  function getCompatibilityLevels(\n    descriptors: CompatibilityToken | RuntimeToken,\n    /**\n     * The `Runtime` of runtimeWithDescriptors already has a RuntimeContext,\n     * which is the runtime of the finalized block.\n     * But on some cases, the user wants to perform an action on a specific\n     * block hash, which has a different RuntimeContext.\n     */\n    ctx?: RuntimeContext,\n  ) {\n    if (descriptors instanceof RuntimeToken) {\n      return {\n        args: CompatibilityLevel.Identical,\n        values: CompatibilityLevel.Identical,\n      }\n    }\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n    ctx ||= compatibilityApi.runtime()\n    const runtimeEntryPoint = getRuntimeEntryPoint(ctx)\n    if (runtimeEntryPoint == null)\n      return {\n        args: CompatibilityLevel.Incompatible,\n        values: CompatibilityLevel.Incompatible,\n      }\n    const descriptorNodes = compatibilityApi.typedefNodes\n\n    const cache = getMetadataCache(ctx)\n\n    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi)\n    const result = entryPointsAreCompatible(\n      descriptorEntryPoint,\n      (id) => descriptorNodes[id],\n      runtimeEntryPoint,\n      (id) => getRuntimeTypedef(ctx, id),\n      cache.compat,\n    )\n    return {\n      args: result.args.level,\n      values: result.values.level,\n    }\n  }\n\n  const getCompatibilityLevel = withOptionalToken(descriptors, (runtime) =>\n    minCompatLevel(getCompatibilityLevels(runtime)),\n  )\n  const isCompatible = withOptionalToken(\n    descriptors,\n    (threshold: CompatibilityLevel, runtime) =>\n      getCompatibilityLevel(runtime) >= threshold,\n  )\n\n  const compatibleRuntime$ = (chainHead: ChainHead$, hash: string | null) =>\n    combineLatest([descriptors, chainHead.getRuntimeContext$(hash)])\n\n  const withCompatibleRuntime =\n    <T>(chainHead: ChainHead$, mapper: (x: T) => string) =>\n    (\n      source$: Observable<T>,\n    ): Observable<[T, CompatibilityToken | RuntimeToken, RuntimeContext]> =>\n      combineLatest([\n        source$.pipe(chainHead.withRuntime(mapper)),\n        descriptors,\n      ]).pipe(map(([[x, ctx], descriptors]) => [x, descriptors, ctx]))\n\n  const argsAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    args: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const levels = getCompatibilityLevels(descriptors, ctx)\n    if (levels.args === CompatibilityLevel.Incompatible) return false\n    if (levels.args > CompatibilityLevel.Partial) return true\n    // Although technically args could still be compatible, if the output will be incompatible we might as well just return false to skip sending the request.\n    if (levels.values === CompatibilityLevel.Incompatible) return false\n\n    const entryPoint = getRuntimeEntryPoint(ctx)\n    if (entryPoint == null) return false\n\n    return valueIsCompatibleWithDest(\n      entryPoint.args,\n      (id) => getRuntimeTypedef(ctx, id),\n      args,\n    )\n  }\n  const valuesAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    values: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const level = getCompatibilityLevels(descriptors, ctx).values\n    if (level === CompatibilityLevel.Incompatible) return false\n    if (level > CompatibilityLevel.Partial) return true\n\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n\n    const entryPoint = getDescriptorEntryPoint(compatibilityApi)\n\n    return valueIsCompatibleWithDest(\n      entryPoint.values,\n      (id) => compatibilityApi.typedefNodes[id],\n      values,\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors,\n    withCompatibleRuntime,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n    getRuntimeTypedef,\n  }\n}\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n\nexport const minCompatLevel = (levels: {\n  args: CompatibilityLevel\n  values: CompatibilityLevel\n}) => Math.min(levels.args, levels.values)\n\nconst withOptionalToken =\n  <T, D, A extends [...any[], CompatibilityToken | RuntimeToken]>(\n    compatibilityToken: Promise<CompatibilityToken<D> | RuntimeToken<D>>,\n    fn: (...args: A) => T,\n  ): WithOptionalRuntime<T, D, A extends [...infer R, any] ? R : []> =>\n  (...args: any): any => {\n    const lastElement = args.at(-1)\n    if (\n      lastElement instanceof CompatibilityToken ||\n      lastElement instanceof RuntimeToken\n    ) {\n      return fn(...args)\n    }\n    return compatibilityToken.then((token) => (fn as any)(...args, token))\n  }\n\nexport type WithOptionalRuntime<T, D, A extends any[]> = {\n  /**\n   * Returns the result after waiting for the runtime to load.\n   */\n  (...args: A): Promise<T>\n  /**\n   * Returns the result synchronously with the loaded runtime.\n   */\n  (...args: [...A, runtime: CompatibilityToken<D> | RuntimeToken<D>]): T\n}\n\nexport interface CompatibilityFunctions<D> {\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   */\n  getCompatibilityLevel(): Promise<CompatibilityLevel>\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   *\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  getCompatibilityLevel(\n    compatibilityToken: CompatibilityToken<D>,\n  ): CompatibilityLevel\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold  CompatibilityLevel threshold to use, inclusive.\n   */\n  isCompatible(threshold: CompatibilityLevel): Promise<boolean>\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold           CompatibilityLevel threshold to use,\n   *                            inclusive.\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  isCompatible(\n    threshold: CompatibilityLevel,\n    compatibilityToken: CompatibilityToken<D>,\n  ): boolean\n}\n"],"names":["OpType","descriptors"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"file":"constants.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/constants.ts"],"sourcesContent":["import { RuntimeContext } from \"@polkadot-api/observable-client\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"./compatibility\"\n\nexport type ConstantEntry<Unsafe, D, T> = Unsafe extends true\n  ? {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (runtimeToken: RuntimeToken): T\n    }\n  : {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (compatibilityToken: CompatibilityToken): T\n    } & CompatibilityFunctions<D>\n\nexport const createConstantEntry = <D, T>(\n  palletName: string,\n  name: string,\n  {\n    valuesAreCompatible,\n    descriptors,\n    isCompatible,\n    getCompatibilityLevel,\n  }: CompatibilityHelper,\n): ConstantEntry<any, D, T> => {\n  const cachedResults = new WeakMap<RuntimeContext, T>()\n  const getValueWithContext = (ctx: RuntimeContext) => {\n    if (cachedResults.has(ctx)) {\n      return cachedResults.get(ctx)!\n    }\n\n    const pallet = ctx.lookup.metadata.pallets.find(\n      (p) => p.name === palletName,\n    )\n    const constant = pallet?.constants.find((c) => c.name === name)\n    if (constant == null)\n      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`)\n    const result = ctx.dynamicBuilder\n      .buildConstant(palletName, name)\n      .dec(constant.value)\n    cachedResults.set(ctx, result)\n    return result\n  }\n\n  const fn = (token?: CompatibilityToken | RuntimeToken): any => {\n    if (token) {\n      const ctx = getCompatibilityApi(token).runtime()\n      const value = getValueWithContext(ctx)\n      if (!valuesAreCompatible(token, ctx, value))\n        throw new Error(\n          `Incompatible runtime entry Constant(${palletName}.${name})`,\n        )\n      return value\n    }\n    return descriptors.then(fn)\n  }\n\n  return Object.assign(fn, { isCompatible, getCompatibilityLevel })\n}\n"],"names":[],"mappings":";;;;;AAyCa,MAAA,mBAAA,GAAsB,CACjC,UAAA,EACA,IACA,EAAA,EACE,mBAAA,EACA,WAAA,EACA,YAAA,EACA,qBAAA,EAE2B,KAAA;IACvB,MAAA,aAAA,GAAA,aAAA,GAAA,IAAoB,OAA2B,EAAA;IAC/C,MAAA,mBAAA,GAAsB,CAAC,GAAwB,KAAA;QAC/C,IAAA,aAAA,CAAc,GAAI,CAAA,GAAG,CAAG,EAAA;YACnB,OAAA,aAAA,CAAc,GAAA,CAAI,GAAG,CAAA;QAAA;QAG9B,MAAM,MAAS,GAAA,GAAA,CAAI,MAAO,CAAA,QAAA,CAAS,OAAQ,CAAA,IAAA,CACzC,CAAC,CAAM,GAAA,CAAA,CAAE,IAAS,KAAA;QAEd,MAAA,QAAA,GAAW,QAAQ,SAAU,CAAA,IAAA,CAAK,CAAC,CAAM,GAAA,CAAA,CAAE,IAAA,KAAS,IAAI,CAAA;QAC9D,IAAI,QAAY,IAAA,IAAA,EACd,MAAM,IAAI,KAAM,CAAA,CAAA,uBAAA,EAA0B,UAAU,CAAA,CAAA,EAAI,IAAI,CAAa,WAAA,CAAA,CAAA;QACrE,MAAA,MAAA,GAAS,IAAI,cAChB,CAAA,aAAA,CAAc,YAAY,IAAI,CAAA,CAC9B,GAAI,CAAA,QAAA,CAAS,KAAK,CAAA;QACP,aAAA,CAAA,GAAA,CAAI,KAAK,MAAM,CAAA;QACtB,OAAA,MAAA;IAAA,CACT;IAEM,MAAA,EAAA,GAAK,CAAC,KAAmD,KAAA;QAC7D,IAAI,KAAO,EAAA;YACT,MAAM,GAAM,uSAAA,sBAAA,EAAoB,KAAK,CAAA,CAAE,OAAQ,EAAA;YACzC,MAAA,KAAA,GAAQ,oBAAoB,GAAG,CAAA;YACrC,IAAI,CAAC,mBAAA,CAAoB,KAAO,EAAA,GAAA,EAAK,KAAK,CAAA,EACxC,MAAM,IAAI,KAAA,CACR,CAAA,oCAAA,EAAuC,UAAU,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA,CAAA;YAEtD,OAAA,KAAA;QAAA;QAEF,OAAA,WAAA,CAAY,IAAA,CAAK,EAAE,CAAA;IAAA,CAC5B;IAEA,OAAO,OAAO,MAAO,CAAA,EAAA,EAAI;QAAE,YAAA;QAAc;IAAA,CAAuB,CAAA;AAClE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"file":"shareLatest.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/utils/shareLatest.ts"],"sourcesContent":["import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n"],"names":[],"mappings":";;;;;;AAEO,MAAM,6OAAyD,QAAA,AAAM,EAAA;IAC1E,SAAW,EAAA,IAAM,0NAAI,gBAAA,CAAc,CAAC,CAAA;IACpC,YAAc,EAAA,IAAA;IACd,eAAiB,EAAA,IAAA;IACjB,mBAAqB,EAAA;AACvB,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"file":"event.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/event.ts"],"sourcesContent":["import { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { concatMapEager, shareLatest } from \"./utils\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<Unsafe, D, T> = {\n  /**\n   * Multicast and stateful Observable watching for new events (matching the\n   * event kind chosen) in the latest known `finalized` block.\n   *\n   * @param filter  Optional filter function to only emit events complying\n   *                with the function.\n   */\n  watch: EvWatch<T>\n  /**\n   * Fetch (Promise-based) all events (matching the event kind chosen) available\n   * in the latest known `finalized` block.\n   */\n  pull: EvPull<T>\n  /**\n   * Filter a bunch of `SystemEvent` and return the decoded `payload` of every\n   * of them.\n   *\n   * @param collection  Array of `SystemEvent` to filter.\n   */\n  filter: EvFilter<T>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <D, T>(\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    withCompatibleRuntime,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): EvClient<any, D, T> => {\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n  const shared$ = chainHead.finalized$.pipe(\n    withCompatibleRuntime(chainHead, (x) => x.hash),\n    map(([block, runtime, ctx]) => {\n      const eventsIdx = ctx.lookup.metadata.pallets.find(\n        (p) => p.name === pallet,\n      )?.events?.type\n      if (\n        eventsIdx == null ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.tag !== \"variant\" ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.value.find(\n          (ev) => ev.name === name,\n        ) == null\n      )\n        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`)\n\n      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError()\n      return [block, runtime, ctx] as const\n    }),\n    concatMapEager(([block, runtime, ctx]) =>\n      chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))\n              throw compatibilityError()\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter, getCompatibilityLevel, isCompatible }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 312, "column": 0}, "map": {"version":3,"file":"firstValueFromWithSignal.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/utils/firstValueFromWithSignal.ts"],"sourcesContent":["import { AbortError } from \"@polkadot-api/utils\"\nimport { Observable, Subscription, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let subscription: Subscription | null = null\n    let isDone = false\n\n    const onAbort = signal\n      ? () => {\n          subscription?.unsubscribe()\n          reject(new AbortError())\n        }\n      : noop\n\n    subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n        subscription?.unsubscribe()\n        isDone = true\n      },\n      error: (e) => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(e)\n        isDone = true\n      },\n      complete: () => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(new Error(\"Observable completed without emitting\"))\n        isDone = true\n      },\n    })\n\n    // the observable could have emitted synchronously\n    if (!isDone) signal?.addEventListener(\"abort\", onAbort)\n  })\n}\n"],"names":[],"mappings":";;;;;;;AAGgB,SAAA,wBAAA,CACd,MAAA,EACA,MACY,EAAA;IACZ,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAW,KAAA;QACtC,IAAI,YAAoC,GAAA,IAAA;QACxC,IAAI,MAAS,GAAA,KAAA;QAEP,MAAA,OAAA,GAAU,SACZ,MAAM;YACJ,YAAA,EAAc,WAAY,EAAA;YACnB,MAAA,CAAA,uPAAI,aAAA,EAAY,CAAA;QAAA,CAEzB,wNAAA,OAAA;QAEJ,YAAA,GAAe,OAAO,SAAU,CAAA;YAC9B,IAAA,EAAM,CAAC,KAAU,KAAA;gBACf,OAAA,CAAQ,KAAK,CAAA;gBACb,YAAA,EAAc,WAAY,EAAA;gBACjB,MAAA,GAAA,IAAA;YAAA,CACX;YACA,KAAA,EAAO,CAAC,CAAM,KAAA;gBACJ,MAAA,EAAA,mBAAA,CAAoB,SAAS,OAAO,CAAA;gBAC5C,MAAA,CAAO,CAAC,CAAA;gBACC,MAAA,GAAA,IAAA;YAAA,CACX;YACA,UAAU,MAAM;gBACN,MAAA,EAAA,mBAAA,CAAoB,SAAS,OAAO,CAAA;gBACrC,MAAA,CAAA,IAAI,KAAM,CAAA,uCAAuC,CAAC,CAAA;gBAChD,MAAA,GAAA,IAAA;YAAA;QACX,CACD,CAAA;QAGD,IAAI,CAAC,MAAA,EAAgB,MAAA,EAAA,gBAAA,CAAiB,SAAS,OAAO,CAAA;IAAA,CACvD,CAAA;AACH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"file":"optional-arg.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/utils/optional-arg.ts"],"sourcesContent":["export const isOptionalArg = (lastArg: unknown) =>\n  typeof lastArg === \"object\" &&\n  lastArg !== null &&\n  Object.entries(lastArg).every(\n    ([k, v]) =>\n      (k === \"at\" && (v === undefined || typeof v === \"string\")) ||\n      (k === \"signal\" && (v === undefined || v instanceof AbortSignal)),\n  )\n"],"names":[],"mappings":";;;AAAa,MAAA,aAAA,GAAgB,CAAC,OAAA,GAC5B,OAAO,OAAA,KAAY,QACnB,IAAA,OAAA,KAAY,IACZ,IAAA,MAAA,CAAO,OAAQ,CAAA,OAAO,CAAE,CAAA,KAAA,CACtB,CAAC,CAAC,CAAA,EAAG,CAAC,CAAA,GACH,MAAM,IAAS,IAAA,CAAA,CAAA,KAAM,KAAA,CAAa,IAAA,OAAO,MAAM,QAC/C,CAAA,IAAA,CAAA,KAAM,QAAa,IAAA,CAAA,CAAA,KAAM,KAAA,KAAa,CAAa,YAAA,WAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"file":"runtime-call.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/runtime-call.ts"],"sourcesContent":["import { firstValueFromWithSignal, isOptionalArg } from \"@/utils\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport type RuntimeCall<Unsafe, D, Args extends Array<any>, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the runtime call.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport const createRuntimeCallEntry = (\n  api: string,\n  method: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): RuntimeCall<any, any, any, any> => {\n  const callName = `${api}_${method}`\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at).pipe(\n      mergeMap(([runtime, ctx]) => {\n        let codecs\n        try {\n          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        } catch {\n          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`)\n        }\n        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError()\n        return chainHead.call$(at, callName, toHex(codecs.args.enc(args))).pipe(\n          map(codecs.value.dec),\n          map((value) => {\n            if (!valuesAreCompatible(runtime, ctx, value))\n              throw compatibilityError()\n            return value\n          }),\n        )\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { getCompatibilityLevel, isCompatible })\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AA0BO,MAAM,sBAAyB,GAAA,CACpC,GACA,EAAA,MAAA,EACA,SACA,EAAA,EACE,YAAA,EACA,qBAAA,EACA,kBAAA,EACA,iBAAA,EACA,mBAAA,EAEkC,KAAA;IACpC,MAAM,QAAW,GAAA,CAAA,EAAG,GAAG,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;IACjC,MAAM,qBAAqB,IACzB,IAAI,KAAM,CAAA,CAAA,uCAAA,EAA0C,QAAQ,CAAG,CAAA,CAAA,CAAA;IAE3D,MAAA,EAAA,GAAK,CAAA,GAAI,IAAqB,KAAA;QAClC,MAAM,OAAU,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,CAAC,CAAA;QAC9B,MAAA,iBAAA,IAAoB,8TAAA,EAAc,OAAO,CAAA;QAC/C,MAAM,EAAE,MAAQ,EAAA,EAAA,EAAI,GAAA,EAAqB,GAAA,iBAAA,GAAoB,UAAU,CAAA,CAAC;QACxE,MAAM,KAAK,GAAO,IAAA,IAAA;QAElB,MAAM,OAAU,GAAA,kBAAA,CAAmB,SAAW,EAAA,EAAE,CAAE,CAAA,IAAA,CAChD,6OAAA,AAAS,EAAA,CAAC,CAAC,OAAA,EAAS,GAAG,CAAM,KAAA;YACvB,IAAA,MAAA;YACA,IAAA;gBACF,MAAA,GAAS,GAAI,CAAA,cAAA,CAAe,gBAAiB,CAAA,GAAA,EAAK,MAAM,CAAA;YAAA,CAClD,CAAA,OAAA;gBACN,MAAM,IAAI,KAAA,CAAM,CAA6B,0BAAA,EAAA,QAAQ,CAAa,WAAA,CAAA,CAAA;YAAA;YAEpE,IAAI,CAAC,iBAAkB,CAAA,OAAA,EAAS,KAAK,IAAI,CAAA,EAAA,MAAS,kBAAmB,EAAA;YAC9D,OAAA,SAAA,CAAU,KAAM,CAAA,EAAA,EAAI,QAAU,GAAA,uPAAA,EAAM,MAAO,CAAA,IAAA,CAAK,GAAI,CAAA,IAAI,CAAC,CAAC,CAAE,CAAA,IAAA,8NACjE,MAAA,EAAI,MAAO,CAAA,KAAA,CAAM,GAAG,CAAA,GACpB,kOAAA,EAAI,CAAC,KAAU,KAAA;gBACb,IAAI,CAAC,mBAAA,CAAoB,OAAS,EAAA,GAAA,EAAK,KAAK,CAAA,EAC1C,MAAM,kBAAmB,EAAA;gBACpB,OAAA,KAAA;YAAA,CACR;QACH,CACD;QAGI,+TAAA,2BAAA,EAAyB,SAAS,MAAM,CAAA;IAAA,CACjD;IAEA,OAAO,OAAO,MAAO,CAAA,EAAA,EAAI;QAAE,qBAAA;QAAuB;IAAA,CAAc,CAAA;AAClE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"file":"lossLessExhaustMap.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/utils/lossLessExhaustMap.ts"],"sourcesContent":["import { Observable, Subscription } from \"rxjs\"\n\nconst EMPTY_VALUE = Symbol(\"EMPTY_VALUE\")\ntype EMPTY_VALUE = typeof EMPTY_VALUE\n\nexport const lossLessExhaustMap =\n  <I, O>(mapper: (x: I, idx: number) => Observable<O>) =>\n  (source$: Observable<I>): Observable<O> =>\n    new Observable((observer) => {\n      let idx = 0\n      let innerSubscription: Subscription | null = null\n      let queuedValue: I | EMPTY_VALUE = EMPTY_VALUE\n      let isOutterDone = false\n\n      const setInnerSubscription = () => {\n        const observable = mapper(queuedValue as I, idx++)\n        queuedValue = EMPTY_VALUE\n        innerSubscription = observable.subscribe({\n          next(vv) {\n            observer.next(vv)\n          },\n          error(ee) {\n            observer.error(ee)\n          },\n          complete() {\n            if (queuedValue !== EMPTY_VALUE) setInnerSubscription()\n            else {\n              innerSubscription = null\n              if (isOutterDone) observer.complete()\n            }\n          },\n        })\n      }\n\n      const subscription = source$.subscribe({\n        next(v) {\n          queuedValue = v\n          if (!innerSubscription) setInnerSubscription()\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (!innerSubscription) observer.complete()\n          isOutterDone = true\n        },\n      })\n\n      return () => {\n        innerSubscription?.unsubscribe()\n        subscription.unsubscribe()\n      }\n    })\n"],"names":[],"mappings":";;;;;AAEA,MAAM,WAAA,GAAc,OAAO,aAAa,CAAA;AAG3B,MAAA,kBAAA,GACX,CAAO,MACP,GAAA,CAAC,UACC,uNAAI,aAAA,CAAW,CAAC,QAAa,KAAA;YAC3B,IAAI,GAAM,GAAA,CAAA;YACV,IAAI,iBAAyC,GAAA,IAAA;YAC7C,IAAI,WAA+B,GAAA,WAAA;YACnC,IAAI,YAAe,GAAA,KAAA;YAEnB,MAAM,uBAAuB,MAAM;gBAC3B,MAAA,UAAA,GAAa,MAAO,CAAA,WAAA,EAAkB,GAAK,EAAA,CAAA;gBACnC,WAAA,GAAA,WAAA;gBACd,iBAAA,GAAoB,WAAW,SAAU,CAAA;oBACvC,MAAK,EAAI,EAAA;wBACP,QAAA,CAAS,IAAA,CAAK,EAAE,CAAA;oBAAA,CAClB;oBACA,OAAM,EAAI,EAAA;wBACR,QAAA,CAAS,KAAA,CAAM,EAAE,CAAA;oBAAA,CACnB;oBACA,QAAW,GAAA;wBACL,IAAA,WAAA,KAAgB,aAAkC,oBAAA,EAAA;6BACjD;4BACiB,iBAAA,GAAA,IAAA;4BAChB,IAAA,YAAA,EAAA,SAAuB,QAAS,EAAA;wBAAA;oBACtC;gBACF,CACD,CAAA;YAAA,CACH;YAEM,MAAA,YAAA,GAAe,QAAQ,SAAU,CAAA;gBACrC,MAAK,CAAG,EAAA;oBACQ,WAAA,GAAA,CAAA;oBACV,IAAA,CAAC,mBAAwC,oBAAA,EAAA;gBAAA,CAC/C;gBACA,OAAM,CAAG,EAAA;oBACP,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA;gBAAA,CAClB;gBACA,QAAW,GAAA;oBACL,IAAA,CAAC,iBAAmB,EAAA,QAAA,CAAS,QAAS,EAAA;oBAC3B,YAAA,GAAA,IAAA;gBAAA;YACjB,CACD,CAAA;YAED,OAAO,MAAM;gBACX,iBAAA,EAAmB,WAAY,EAAA;gBAC/B,YAAA,CAAa,WAAY,EAAA;YAAA,CAC3B;QACF,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 474, "column": 0}, "map": {"version":3,"file":"storage.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/storage.ts"],"sourcesContent":["import {\n  firstValueFromWithSignal,\n  isOptionalArg,\n  lossLessExhaustMap,\n} from \"@/utils\"\nimport { CompatibilityLevel } from \"@polkadot-api/metadata-compatibility\"\nimport {\n  BlockInfo,\n  BlockNotPinnedError,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport { FixedSizeBinary, HexString } from \"@polkadot-api/substrate-bindings\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  OperatorFunction,\n  catchError,\n  combineLatestWith,\n  distinctUntilChanged,\n  filter,\n  from,\n  identity,\n  map,\n  mergeMap,\n  pipe,\n  shareReplay,\n  take,\n} from \"rxjs\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  minCompatLevel,\n  RuntimeToken,\n} from \"./compatibility\"\nimport { createWatchEntries } from \"./watch-entries\"\n\ntype CallOptions = Partial<{\n  /**\n   * `at` could be a blockHash, `best`, or `finalized` (default)\n   */\n  at: string\n  /**\n   * `signal` allows you to abort an ongoing Promise. See [MDN\n   * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for\n   * more information\n   */\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype WithWatchOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: { at: \"best\" },\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : ArrayPossibleParents<A>\n\ntype AllPermutations<A extends Array<any>> = PossibleParents<A> | A\n\n// Fixed-size arrays values can't be extracted one-by-one, so that's a specific case\ntype ArrayPossibleParents<\n  A extends Array<any>,\n  Count extends Array<any> = [],\n  R = [],\n> = A extends Array<infer T> & { length: infer L }\n  ? number extends L\n    ? Array<T> // Case variable-size array it's an unknown amount of entries\n    : L extends Count[\"length\"]\n      ? R\n      : ArrayPossibleParents<A, [...Count, T], R | Count>\n  : never\n\ntype GetKey<Args extends Array<any>, Unsafe> = Unsafe extends true\n  ? {\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param args  All keys needed for that storage entry.\n       * @returns Promise that will resolve the hexadecimal value of the\n       *          storage key.\n       */\n      (...args: AllPermutations<Args>): Promise<HexString>\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param ...args       All keys needed for that storage entry.\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns the hexadecimal value of the\n       *          storage key.\n       */\n      (\n        ...args: [...AllPermutations<Args>, runtimeToken: RuntimeToken]\n      ): HexString\n    }\n  : {\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param args  All keys needed for that storage entry.\n       * @returns Promise that will resolve the hexadecimal value of the\n       *          storage key.\n       */\n      (...args: AllPermutations<Args>): Promise<HexString>\n      /**\n       * Get the storage-key for this storage entry.\n       *\n       * @param ...args             All keys needed for that storage entry.\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns the hexadecimal value of the\n       *          storage key.\n       */\n      (\n        ...args: [\n          ...AllPermutations<Args>,\n          compatibilityToken: CompatibilityToken,\n        ]\n      ): HexString\n    }\n\ntype StorageEntryWithoutKeys<Unsafe, D, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: CallOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n  getKey: GetKey<[], Unsafe>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntryWithKeys<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  Payload,\n  ArgsOut extends Array<any>,\n> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: ArgsOut; value: NonNullable<Payload> }>>\n  /**\n   * Watch changes (Observable-based) for the storage entries with a subset of\n   * `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set whether to watch against the\n   *              `best` block.\n   *              By default watches changes against the finalized block.\n   *              When watching changes against the \"best\" block, this API\n   *              gratiously handles the re-orgs and provides the deltas\n   *              based on the latest emission.\n   *              The observed value contains the following properties:\n   *              - `block`: the block in where the `deltas` took place -\n   *              `deltas`: `null` indicates that nothing has changed from\n   *              the latest emission.\n   *              If the value is not `null` then the `deleted` and `upsrted`\n   *              properties indicate the entries that have changed.\n   *              - `entries`: it's an immutable data-structure with the\n   *              latest entries.\n   * @example\n   *\n   *   typedApi.query.Staking.Nominators.watchEntries()\n   *   typedApi.query.Staking.Nominators.watchEntries({ at: \"best\" })\n   *\n   */\n  watchEntries: (\n    ...args: WithWatchOptions<PossibleParents<Args>>\n  ) => Observable<{\n    block: BlockInfo\n    deltas: null | {\n      deleted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n      upserted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n    }\n    entries: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n  }>\n\n  getKey: GetKey<Args, Unsafe>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntry<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  ArgsOut extends Array<any>,\n  Payload,\n> = Args extends []\n  ? StorageEntryWithoutKeys<Unsafe, D, Payload>\n  : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst toMapped = map(<T>(x: { mapped: T }) => x.mapped)\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  getWatchEntries: ReturnType<typeof createWatchEntries>,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors: descriptorsPromise,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): StorageEntry<any, any, any, any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const isBlockHash = pallet === \"System\" && name === \"BlockHash\"\n  const sysNumberMapper$ = chainHead.runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    map(({ dynamicBuilder }) =>\n      typeof dynamicBuilder\n        .buildStorage(\"System\", \"Number\")\n        .value.dec(new Uint8Array(32)) === \"bigint\"\n        ? BigInt\n        : identity,\n    ),\n    shareReplay(),\n  )\n  const bigIntOrNumber: OperatorFunction<number, number | bigint> = pipe(\n    combineLatestWith(sysNumberMapper$),\n    map(([input, mapper]) => mapper(input)),\n  )\n\n  const incompatibleError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const getCodec = (ctx: RuntimeContext) => {\n    try {\n      return ctx.dynamicBuilder.buildStorage(pallet, name)\n    } catch (e: any) {\n      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`)\n    }\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const isBest = target === \"best\"\n    const actualArgs =\n      isBest || target === \"finalized\" ? args.slice(0, -1) : args\n\n    return chainHead[isBest ? \"best$\" : \"finalized$\"].pipe(\n      lossLessExhaustMap(() =>\n        getRawValue$(...actualArgs, isBest ? { at: \"best\" } : {}),\n      ),\n      distinctUntilChanged((a, b) => a.raw === b.raw),\n      toMapped,\n    )\n  }\n\n  const getRawValue$ = (\n    ...args: Array<any>\n  ): Observable<{ raw: string | null; mapped: any }> => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"value\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            const actualArgs =\n              args.length === codecs.len ? args : args.slice(0, -1)\n            if (args !== actualArgs && !isLastArgOptional)\n              throw invalidArgs(args)\n            if (!argsAreCompatible(descriptors, ctx, actualArgs))\n              throw incompatibleError()\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (data, ctx) => {\n            const codecs = getCodec(ctx)\n            const mapped =\n              data === null ? codecs.fallback : codecs.value.dec(data)\n            if (!valuesAreCompatible(descriptors, ctx, mapped))\n              throw incompatibleError()\n            return { raw: data, mapped }\n          },\n        ),\n      ),\n    )\n\n    if (isSystemNumber)\n      return chainHead.pinnedBlocks$.pipe(\n        map((blocks) => {\n          const hash =\n            at === \"finalized\" || !at\n              ? blocks.finalized\n              : at === \"best\"\n                ? blocks.best\n                : at\n          const block = blocks.blocks.get(hash)\n          if (!block) {\n            throw new BlockNotPinnedError(hash, \"System.Number\")\n          }\n          return block.number\n        }),\n        distinctUntilChanged(),\n        bigIntOrNumber,\n        map((mapped) => ({ raw: mapped.toString(), mapped })),\n        catchError((e) => {\n          if (e instanceof BlockNotPinnedError) return result$\n          throw e\n        }),\n      )\n\n    return isBlockHash && Number(args[0]) === 0\n      ? chainHead.genesis$.pipe(\n          map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) })),\n        )\n      : result$\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal }: CallOptions = isLastArgOptional ? lastArg : {}\n\n    return firstValueFromWithSignal(\n      getRawValue$(...args).pipe(toMapped),\n      signal,\n    )\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const descriptors = await descriptorsPromise\n    const result$ = chainHead.storage$(\n      at,\n      \"descendantsValues\",\n      (ctx) => {\n        const codecs = getCodec(ctx)\n        // TODO partial compatibility check for args that become optional\n        if (\n          minCompatLevel(getCompatibilityLevels(descriptors, ctx)) ===\n          CompatibilityLevel.Incompatible\n        )\n          throw incompatibleError()\n\n        if (args.length > codecs.len) throw invalidArgs(args)\n        const actualArgs =\n          args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n        if (args.length === codecs.len && actualArgs === args)\n          throw invalidArgs(args)\n        return codecs.keys.enc(...actualArgs)\n      },\n      null,\n      (values, ctx) => {\n        const codecs = getCodec(ctx)\n        const decodedValues = values.map(({ key, value }) => ({\n          keyArgs: codecs.keys.dec(key),\n          value: codecs.value.dec(value),\n        }))\n        if (\n          decodedValues.some(\n            ({ value }) => !valuesAreCompatible(descriptors, ctx, value),\n          )\n        )\n          throw incompatibleError()\n        return decodedValues\n      },\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  const watchEntries: any = (...args: Array<any>) => {\n    const lastArg = args.at(-1)\n    const isLastArgOptional = isOptionalArg(lastArg)\n\n    return getWatchEntries(\n      pallet,\n      name,\n      isLastArgOptional ? args.slice(0, -1) : args,\n      isLastArgOptional && lastArg.at === \"best\",\n    )\n  }\n\n  const getKey = (...args: Array<any>): Promise<string> | string => {\n    const token = args.at(-1)\n    if (token instanceof CompatibilityToken || token instanceof RuntimeToken) {\n      const actualArgs = args.slice(0, -1)\n      const ctx = getCompatibilityApi(token).runtime()\n      if (!argsAreCompatible(token, ctx, actualArgs)) throw incompatibleError()\n      return getCodec(ctx).keys.enc(...actualArgs)\n    }\n    return descriptorsPromise.then((x) => getKey(...args, x))\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getKey: getKey as GetKey<any, any>,\n    getValue,\n    getValues,\n    getEntries,\n    watchValue,\n    watchEntries,\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 635, "column": 0}, "map": {"version":3,"file":"system-version.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/tx/signed-extensions/system-version.ts"],"sourcesContent":["import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\n\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\nexport const getSystemVersionStruct = (\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n): Record<string, any> => {\n  const constant = lookupFn.metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"Version\")!\n\n  const systemVersion = lookupFn(constant.type)\n  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec\n\n  if (systemVersion.type !== \"struct\") throw new Error(\"not a struct\")\n  return systemVersionDec(constant.value)\n}\n"],"names":[],"mappings":";;;AAMa,MAAA,sBAAA,GAAyB,CACpC,QAAA,EACA,cACwB,KAAA;IACxB,MAAM,WAAW,QAAS,CAAA,QAAA,CAAS,OAChC,CAAA,IAAA,CAAK,CAAC,CAAM,GAAA,CAAA,CAAE,IAAS,KAAA,QAAQ,EAC/B,SAAW,CAAA,IAAA,CAAK,CAAC,CAAM,GAAA,CAAA,CAAE,IAAA,KAAS,SAAS,CAAA;IAExC,MAAA,aAAA,GAAgB,QAAS,CAAA,QAAA,CAAS,IAAI,CAAA;IAC5C,MAAM,gBAAmB,GAAA,cAAA,CAAe,eAAgB,CAAA,QAAA,CAAS,IAAI,CAAE,CAAA,GAAA;IAEvE,IAAI,cAAc,IAAS,KAAA,QAAA,EAAgB,MAAA,IAAI,MAAM,cAAc,CAAA;IAC5D,OAAA,gBAAA,CAAiB,SAAS,KAAK,CAAA;AACxC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 653, "column": 0}, "map": {"version":3,"file":"mortal-enc.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/tx/signed-extensions/mortal-enc.ts"],"sourcesContent":["import { Bytes, enhanceEncoder, u16 } from \"@polkadot-api/substrate-bindings\"\n\nfunction trailingZeroes(n: number) {\n  let i = 0\n  while (!(n & 1)) {\n    i++\n    n >>= 1\n  }\n  return i\n}\n\nconst nextPower = (n: number) => 1 << Math.ceil(Math.log2(n))\n\nexport const mortal = enhanceEncoder(\n  Bytes(2)[0],\n  (value: { period: number; startAtBlock: number }) => {\n    const period = Math.min(Math.max(nextPower(value.period), 4), 1 << 16)\n    const phase = value.startAtBlock % period\n    const factor = Math.max(period >> 12, 1)\n    const left = Math.min(Math.max(trailingZeroes(period) - 1, 1), 15)\n    const right = (phase / factor) << 4\n    return u16[0](left | right)\n  },\n)\n"],"names":[],"mappings":";;;;;AAEA,SAAS,eAAe,CAAW,EAAA;IACjC,IAAI,CAAI,GAAA,CAAA;IACD,MAAA,CAAA,CAAE,IAAI,CAAI,CAAA,CAAA;QACf,CAAA,EAAA;QACM,CAAA,KAAA,CAAA;IAAA;IAED,OAAA,CAAA;AACT;AAEA,MAAM,SAAA,GAAY,CAAC,CAAc,GAAA,CAAA,IAAK,KAAK,IAAK,CAAA,IAAA,CAAK,IAAK,CAAA,CAAC,CAAC,CAAA;AAErD,MAAM,MAAS,qNAAA,iBAAA,oNACpB,QAAA,EAAM,CAAC,CAAA,CAAE,CAAC,CAAA,EACV,CAAC,KAAoD,KAAA;IACnD,MAAM,MAAS,GAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,GAAI,CAAA,SAAA,CAAU,KAAM,CAAA,MAAM,CAAG,EAAA,CAAC,CAAG,EAAA,CAAA,IAAK,EAAE,CAAA;IAC/D,MAAA,KAAA,GAAQ,MAAM,YAAe,GAAA,MAAA;IACnC,MAAM,MAAS,GAAA,IAAA,CAAK,GAAI,CAAA,MAAA,IAAU,IAAI,CAAC,CAAA;IACjC,MAAA,IAAA,GAAO,IAAK,CAAA,GAAA,CAAI,IAAK,CAAA,GAAA,CAAI,cAAe,CAAA,MAAM,CAAI,GAAA,CAAA,EAAG,CAAC,CAAA,EAAG,EAAE,CAAA;IAC3D,MAAA,KAAA,GAAS,QAAQ,MAAW,IAAA,CAAA;IAClC,qNAAO,MAAI,CAAA,CAAC,CAAE,CAAA,IAAA,GAAO,KAAK,CAAA;AAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 683, "column": 0}, "map": {"version":3,"file":"charge-asset-tx-enc.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/tx/signed-extensions/charge-asset-tx-enc.ts"],"sourcesContent":["import {\n  Bytes,\n  compact,\n  Option,\n  Struct,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const [ChargeAssetTxPaymentEnc] = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n})\n"],"names":[],"mappings":";;;;;;AAOa,MAAA,CAAC,uBAAuB,CAAA,0SAAI,SAAA,AAAO,EAAA;IAC9C,GAAK,gNAAA,UAAA;IACL,KAAO,ySAAA,SAAA,oNAAO,QAAA,AAAM,EAAA,QAAQ,CAAC;AAC/B,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 701, "column": 0}, "map": {"version":3,"file":"sign-extensions.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/tx/signed-extensions/sign-extensions.ts"],"sourcesContent":["import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport { Encoder } from \"@polkadot-api/substrate-bindings\"\nimport { OfflineTxExtensions } from \"../types\"\nimport { fromHex, mapObject } from \"@polkadot-api/utils\"\nimport { getSystemVersionStruct } from \"./system-version\"\nimport { mortal } from \"./mortal-enc\"\nimport { ChargeAssetTxPaymentEnc } from \"./charge-asset-tx-enc\"\n\nconst empty = new Uint8Array()\nconst zero = Uint8Array.from([0])\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\n\nconst value = (value: Uint8Array) => ({\n  value,\n  additionalSigned: empty,\n})\nconst additionalSigned = (additionalSigned: Uint8Array) => ({\n  value: empty,\n  additionalSigned,\n})\nconst both = (value: Uint8Array, additionalSigned: Uint8Array) => ({\n  value,\n  additionalSigned,\n})\n\nexport const getSignExtensionsCreator = (\n  genesis: Uint8Array,\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n) => {\n  const signedExtensionsEncoders: Record<string, [Encoder<any>, Encoder<any>]> =\n    {}\n  lookupFn.metadata.extrinsic.signedExtensions.forEach(\n    ({ identifier, type, additionalSigned }) => {\n      signedExtensionsEncoders[identifier] = [type, additionalSigned].map(\n        (x) => dynamicBuilder.buildDefinition(x)[0],\n      ) as [Encoder<any>, Encoder<any>]\n    },\n  )\n\n  return <Asset>({\n    mortality,\n    tip = 0n,\n    nonce,\n    customSignedExtensions = {},\n    ...rest\n  }: OfflineTxExtensions<Asset>): Record<\n    string,\n    { identifier: string; value: Uint8Array; additionalSigned: Uint8Array }\n  > => {\n    const invalidKeys: string[] = []\n    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder)\n    const getFromCustomEntry = (key: string) => {\n      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key]\n      const customEntry = customSignedExtensions[key] as any\n      try {\n        return mapObject(\n          {\n            value: valueEnc,\n            additionalSigned: additionalEnc,\n          },\n          (encoder, key) => {\n            const input = customEntry?.[key]\n            // if the encoder is _void, then the input value is ignored, so no harm in passing `undefined`\n            // only an `Option` encoder will accept `undefined` as an input without crashing\n            return input instanceof Uint8Array ? input : encoder(input)\n          },\n        )\n      } catch {\n        // this means that a non optional custom signed-extension has not received its value\n        invalidKeys.push(key)\n        return null\n      }\n    }\n\n    const result = mapObject(\n      signedExtensionsEncoders,\n      ([valueEnc, additionalEnc], key) => {\n        if (customSignedExtensions[key]) return getFromCustomEntry(key)\n\n        switch (key) {\n          case \"CheckNonce\":\n            return value(valueEnc(nonce))\n\n          case \"CheckMortality\":\n            return mortality.mortal\n              ? both(\n                  mortal({\n                    period: mortality.period,\n                    startAtBlock: mortality.startAtBlock.height,\n                  }),\n                  fromHex(mortality.startAtBlock.hash),\n                )\n              : both(zero, genesis)\n\n          case \"ChargeTransactionPayment\":\n            return value(valueEnc(tip))\n\n          case \"ChargeAssetTxPayment\":\n            return value(\n              ChargeAssetTxPaymentEnc({\n                tip,\n                asset: (rest as any).asset,\n              }),\n            )\n\n          case \"CheckGenesis\":\n            return additionalSigned(genesis)\n\n          case \"CheckMetadataHash\":\n            return both(zero, zero)\n\n          case \"CheckSpecVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"spec_version\"]),\n            )\n\n          case \"CheckTxVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"transaction_version\"]),\n            )\n\n          default:\n            return getFromCustomEntry(key)\n        }\n      },\n    )\n\n    invalidKeys.forEach((key) => {\n      delete result[key]\n    })\n    return mapObject(result, (x, identifier) => ({ ...x, identifier })) as any\n  }\n}\n"],"names":["value","additionalSigned","key"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"file":"create-tx.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/tx/create-tx.ts"],"sourcesContent":["import { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { HexString, u16, u32, u64, u8 } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  filter,\n  map,\n  mergeMap,\n  of,\n  scan,\n  startWith,\n  switchMap,\n  take,\n} from \"rxjs\"\nimport { getSignExtensionsCreator } from \"./signed-extensions\"\nimport { CustomSignedExtensionValues } from \"./types\"\n\ntype HintedSignedExtensions = Partial<{\n  tip: bigint\n  mortality: { mortal: false } | { mortal: true; period: number }\n  asset: Uint8Array\n  nonce: number\n}>\n\nconst NONCE_RUNTIME_CALL = \"AccountNonceApi_account_nonce\"\nconst lenToDecoder = {\n  1: u8.dec,\n  2: u16.dec,\n  4: u32.dec,\n  8: u64.dec,\n}\n\nconst getNonceAtBlock$ = (\n  call$: ChainHead$[\"call$\"],\n  from: HexString,\n  at: string,\n) =>\n  call$(at, NONCE_RUNTIME_CALL, from).pipe(\n    map((result) => {\n      const bytes = fromHex(result)\n      const decoder = lenToDecoder[bytes.length as 2 | 4 | 8]\n      if (!decoder)\n        throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`)\n      return decoder(bytes)\n    }),\n  )\n\nexport const createTx: (\n  chainHead: ChainHead$,\n  signer: PolkadotSigner,\n  callData: Uint8Array,\n  atBlock: BlockInfo,\n  customSignExt: Record<string, CustomSignedExtensionValues>,\n  hinted?: HintedSignedExtensions,\n) => Observable<Uint8Array> = (\n  chainHead,\n  signer,\n  callData,\n  atBlock,\n  customSignedExtensions,\n  hinted = {},\n) =>\n  combineLatest([\n    hinted.nonce\n      ? of(hinted.nonce)\n      : getNonce$(chainHead, toHex(signer.publicKey)),\n    chainHead.getRuntimeContext$(atBlock.hash),\n    chainHead.genesis$,\n  ]).pipe(\n    take(1),\n    mergeMap(([nonce, ctx, genesis]) => {\n      const signExtCreator = getSignExtensionsCreator(\n        fromHex(genesis),\n        ctx.lookup,\n        ctx.dynamicBuilder,\n      )\n\n      const mortality: HintedSignedExtensions[\"mortality\"] =\n        hinted.mortality ?? { period: 64, mortal: true }\n\n      const signExtensions = signExtCreator({\n        nonce: nonce as number,\n        tip: hinted.tip ?? 0n,\n        mortality: mortality.mortal\n          ? {\n              mortal: true,\n              period: mortality.period,\n              startAtBlock: {\n                height: atBlock.number,\n                hash: atBlock.hash,\n              },\n            }\n          : { mortal: false },\n        customSignedExtensions,\n        asset: hinted.asset,\n      })\n\n      return signer.signTx(\n        callData,\n        signExtensions,\n        ctx.metadataRaw,\n        atBlock.number,\n      )\n    }),\n  )\n\nconst getNonce$ = (chainHead: ChainHead$, from: HexString) => {\n  const followHead$ = (head: string) =>\n    chainHead.newBlocks$.pipe(\n      scan((acc, block) => (block.parent === acc ? block.hash : acc), head),\n      startWith(head),\n      distinctUntilChanged(),\n    )\n  const followNonce$ = (head: string) =>\n    followHead$(head).pipe(\n      take(2),\n      switchMap((hash) => getNonceAtBlock$(chainHead.call$, from, hash)),\n    )\n  const getHeadsNonce$ = (heads: string[]) =>\n    combineLatest(\n      heads.map((head) =>\n        followNonce$(head).pipe(\n          map((value) => ({\n            success: true as const,\n            value,\n          })),\n          catchError((err) =>\n            of({\n              success: false as const,\n              value: err,\n            }),\n          ),\n        ),\n      ),\n    ).pipe(take(1))\n\n  return chainHead.pinnedBlocks$.pipe(\n    filter((v) => !v.recovering && v.blocks.size > 0),\n    take(1),\n    map(({ blocks, best }) => {\n      // Grab only the heads: those blocks above the best that don't have children and are not getting pruned\n      const bestBlock = blocks.get(best)!\n      return [...blocks.values()]\n        .filter(\n          (v) =>\n            !v.unpinnable &&\n            v.children.size === 0 &&\n            v.number >= bestBlock.number,\n        )\n        .map((v) => v.hash)\n    }),\n    switchMap(getHeadsNonce$),\n    map((result) => {\n      const winner = result.reduce(\n        (acc: bigint | number | null, v) =>\n          v.success ? (v.value >= (acc ?? 0) ? v.value : acc) : acc,\n        null,\n      )\n\n      if (winner == null) {\n        // We must have at least one error\n        throw result[0].value\n      }\n      return winner\n    }),\n  )\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 895, "column": 0}, "map": {"version":3,"file":"continue-with.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/utils/continue-with.ts"],"sourcesContent":["import { Observable } from \"rxjs\"\n\nlet NOTIN = {}\nexport const continueWith =\n  <I, O>(\n    mapper: (input: I) => Observable<O>,\n  ): ((source: Observable<I>) => Observable<I | O>) =>\n  (source) =>\n    new Observable((observer) => {\n      let latestValue: I = NOTIN as I\n      let subscription = source.subscribe({\n        next(v) {\n          observer.next((latestValue = v))\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (latestValue === NOTIN) observer.complete()\n          else subscription = mapper(latestValue).subscribe(observer)\n        },\n      })\n\n      return () => {\n        subscription.unsubscribe()\n      }\n    })\n"],"names":[],"mappings":";;;;;AAEA,IAAI,QAAQ,CAAA,CAAC;AACA,MAAA,YAAA,GACX,CACE,MAEF,GAAA,CAAC,SACC,uNAAI,aAAA,CAAW,CAAC,QAAa,KAAA;YAC3B,IAAI,WAAiB,GAAA,KAAA;YACjB,IAAA,YAAA,GAAe,OAAO,SAAU,CAAA;gBAClC,MAAK,CAAG,EAAA;oBACG,QAAA,CAAA,IAAA,CAAM,cAAc,CAAE,CAAA;gBAAA,CACjC;gBACA,OAAM,CAAG,EAAA;oBACP,QAAA,CAAS,KAAA,CAAM,CAAC,CAAA;gBAAA,CAClB;gBACA,QAAW,GAAA;oBACL,IAAA,WAAA,KAAgB,KAAO,EAAA,QAAA,CAAS,QAAS,EAAA;yBACzB,YAAA,GAAA,MAAA,CAAO,WAAW,CAAA,CAAE,SAAA,CAAU,QAAQ,CAAA;gBAAA;YAC5D,CACD,CAAA;YAED,OAAO,MAAM;gBACX,YAAA,CAAa,WAAY,EAAA;YAAA,CAC3B;QACF,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 927, "column": 0}, "map": {"version":3,"file":"submit-fns.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/tx/submit-fns.ts"],"sourcesContent":["import {\n  Binary,\n  Blake2256,\n  HexString,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  catchError,\n  concat,\n  distinctUntilChanged,\n  filter,\n  lastValueFrom,\n  map,\n  merge,\n  mergeMap,\n  of,\n  reduce,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport {\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\n// TODO: make it dynamic based on the tx-function of the client\nconst hashFromTx = (tx: HexString) => toHex(Blake2256(fromHex(tx)))\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        found: true\n        hash: string\n        number: number\n        index: number\n        events: any\n      }\n    | { found: false; validity: ResultPayload<any, any> | null }\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          found: true\n          hash: string\n          number: number\n          index: number\n          events: any\n        }\n      | { found: false; validity: ResultPayload<any, any> | null }\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n      let analyzedNumber = pinnedBlocks.blocks.get(current)!.number\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n        analyzedNumber--\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        analyzedNumber <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (found && latestState?.found && latestState.hash === analyzed.hash) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = analyzed.found.type\n          ? {\n              found: found as true,\n              hash: analyzed.hash,\n              number: analyzedNumber,\n              index: analyzed.found.index,\n              events: analyzed.found.events,\n            }\n          : {\n              found: found as false,\n              validity: analyzed.found.validity,\n            }),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (analyzed.found.validity?.success === false)\n          observer.error(new InvalidTxError(analyzed.found.validity.value))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => ({ ...x.event, topics: x.topics }))\n\n  const lastEvent = events[events.length - 1]\n  if (\n    lastEvent.type === \"System\" &&\n    lastEvent.value.type === \"ExtrinsicFailed\"\n  ) {\n    return {\n      ok: false,\n      events,\n      dispatchError: lastEvent.value.value.dispatch_error,\n    }\n  }\n\n  return { ok: true, events }\n}\n\n/*\ntype TransactionValidityError = Enum<{\n  Invalid: Enum<{\n    Call: undefined\n    Payment: undefined\n    Future: undefined\n    Stale: undefined\n    BadProof: undefined\n    AncientBirthBlock: undefined\n    ExhaustsResources: undefined\n    Custom: number\n    BadMandatory: undefined\n    MandatoryValidation: undefined\n    BadSigner: undefined\n  }>\n  Unknown: Enum<{\n    CannotLookup: undefined\n    NoUnsignedValidator: undefined\n    Custom: number\n  }>\n}>\n*/\n\nexport class InvalidTxError extends Error {\n  error: any // likely to be a `TransactionValidityError`\n  constructor(e: any) {\n    super(\n      JSON.stringify(\n        e,\n        (_, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value instanceof Binary ? value.asHex() : value\n        },\n        2,\n      ),\n    )\n    this.name = \"InvalidTxError\"\n    this.error = e\n  }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  emitSign = false,\n): Observable<TxEvent> => {\n  const txHash = hashFromTx(tx)\n  const getTxEvent = <\n    Type extends TxEvent[\"type\"],\n    Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n  >(\n    type: Type,\n    rest: Rest,\n  ): TxEvent & { type: Type } =>\n    ({\n      type,\n      txHash,\n      ...rest,\n    }) as any\n\n  const validate$ = chainHead.pinnedBlocks$.pipe(\n    take(1),\n    mergeMap((blocks) => {\n      let bestBlocks: string[] = []\n      return blocks.finalizedRuntime.runtime.pipe(\n        map((r) => r.getMortalityFromTx(tx)),\n        catchError(() => of({ mortal: false as const })),\n        map((x) => {\n          const { best, finalized } = blocks\n\n          // before we start doing async stuff, we must \"take a picture\"\n          // of the current lineage of best-blocks\n          let current = best\n          while (current !== finalized) {\n            bestBlocks.push(current)\n            current = blocks.blocks.get(current)!.parent\n          }\n          bestBlocks.push(finalized)\n\n          if (!x.mortal) return [finalized, best]\n\n          const { phase, period } = x\n          const bestBlock = blocks.blocks.get(best)!\n          const topNumber = bestBlock.number\n          const txBlockNumber =\n            Math.floor((topNumber - phase) / period) * period + phase\n\n          let result = [blocks.blocks.get(blocks.finalized)!]\n          while (result.length && result[0].number < txBlockNumber) {\n            result = result\n              .flatMap((x) => [...x.children])\n              .map((x) => blocks.blocks.get(x)!)\n              .filter(Boolean)\n          }\n          return (result.length ? result : [bestBlock]).map((x) => x.hash)\n        }),\n        mergeMap((toCheck) =>\n          merge(\n            ...[...new Set(toCheck)].map((at) =>\n              chainHead\n                .validateTx$(at, tx)\n                .pipe(map((result) => ({ at, result }))),\n            ),\n          ),\n        ),\n        takeWhile(({ result }) => !result.success, true),\n        reduce(\n          (acc, curr) => [...acc, curr],\n          [] as { at: string; result: ResultPayload<any, any> }[],\n        ),\n        map((results) => {\n          const badOnes = new Map(\n            results\n              .filter(({ result }) => !result.success)\n              .map((x) => [x.at, x.result]),\n          )\n          if (badOnes.size < results.length) return null\n\n          throw new InvalidTxError(\n            badOnes.get(\n              // there is a possible, but very unlikely, race-condition in which:\n              // we have received a new block that is about to be flagged as best,\n              // and that its height is higher than all the others, but the notification\n              // that sets it as best has not arrived yet. In that case, that block wouldn't\n              // be in the lineage of the best-blocks, but then it would be the only one in the list of `badOnes`\n              bestBlocks.find((x) => badOnes.has(x)) ?? [...badOnes.keys()][0],\n            )!.value,\n          )\n        }),\n        filter(Boolean),\n      )\n    }),\n  )\n\n  const track$ = new Observable<AnalyzedBlock>((observer) => {\n    const subscription = chainHead.trackTx$(tx).subscribe(observer)\n    subscription.add(\n      broadcastTx$(tx).subscribe({\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n    return subscription\n  })\n\n  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(\n    map((x) => {\n      if (!x.found)\n        return getTxEvent(\"txBestBlocksState\", {\n          found: false,\n          isValid: x.validity?.success !== false,\n        })\n\n      return getTxEvent(\"txBestBlocksState\", {\n        found: true,\n        block: {\n          index: x.index,\n          number: x.number,\n          hash: x.hash,\n        },\n        ...getTxSuccessFromSystemEvents(x.events, x.index),\n      })\n    }),\n  )\n\n  return concat(\n    emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n    validate$,\n    of(getTxEvent(\"broadcasted\", {})),\n    bestBlockState$.pipe(\n      continueWith(({ found, type, ...rest }) =>\n        found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n      ),\n    ),\n  )\n}\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  _at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n"],"names":["x"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1157, "column": 0}, "map": {"version":3,"file":"tx.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/tx/tx.ts"],"sourcesContent":["import type { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getPolkadotSigner } from \"@polkadot-api/signer\"\nimport {\n  _void,\n  AccountId,\n  Binary,\n  compactBn,\n  Decoder,\n  Enum,\n  Struct,\n  u128,\n  u32,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  combineLatest,\n  firstValueFrom,\n  map,\n  mergeMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport { PlainDescriptor } from \"@/descriptors\"\nimport {\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"../compatibility\"\nimport { createTx } from \"./create-tx\"\nimport { InvalidTxError, submit, submit$ } from \"./submit-fns\"\nimport {\n  PaymentInfo,\n  TxCall,\n  TxEntry,\n  TxObservable,\n  TxOptions,\n  TxPromise,\n  TxSignFn,\n} from \"./types\"\nimport {\n  isCompatible,\n  mapLookupToTypedef,\n} from \"@polkadot-api/metadata-compatibility\"\n\nexport { submit, submit$, InvalidTxError }\n\nconst accountIdEnc = AccountId().enc\nconst fakeSignature = new Uint8Array(64)\nconst fakeSignatureEth = new Uint8Array(65)\nconst getFakeSignature = (isEth: boolean) => () =>\n  isEth ? fakeSignatureEth : fakeSignature\n\nconst [, queryInfoDecFallback] = Struct({\n  weight: Struct({\n    ref_time: compactBn,\n    proof_size: compactBn,\n  }),\n  class: Variant({\n    Normal: _void,\n    Operational: _void,\n    Mandatory: _void,\n  }),\n  partial_fee: u128,\n})\n\nexport const createTxEntry = <\n  D,\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends PlainDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  chainHead: ChainHead$,\n  broadcast: (tx: string) => Observable<never>,\n  {\n    isCompatible: isCompatibleHelper,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    getRuntimeTypedef,\n  }: CompatibilityHelper,\n  checkCompatibility: boolean,\n): TxEntry<D, Arg, Pallet, Name, Asset> => {\n  const fn = (arg?: Arg): any => {\n    const getCallDataWithContext = (\n      runtime: CompatibilityToken | RuntimeToken,\n      arg: any,\n      txOptions: Partial<{ asset: any }> = {},\n    ) => {\n      const ctx = getCompatibilityApi(runtime).runtime()\n      const { dynamicBuilder, assetId, lookup } = ctx\n      let codecs\n      try {\n        codecs = dynamicBuilder.buildCall(pallet, name)\n      } catch {\n        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`)\n      }\n      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg))\n        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n      let returnOptions = txOptions\n      if (txOptions.asset) {\n        if (\n          assetId == null ||\n          !isCompatible(\n            txOptions.asset,\n            mapLookupToTypedef(lookup(assetId)),\n            (id) => getRuntimeTypedef(ctx, id),\n          )\n        )\n          throw new Error(`Incompatible runtime asset`)\n        returnOptions = {\n          ...txOptions,\n          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset),\n        }\n      }\n\n      const { location, codec } = codecs\n      return {\n        callData: Binary.fromBytes(\n          mergeUint8([new Uint8Array(location), codec.enc(arg)]),\n        ),\n        options: returnOptions,\n      }\n    }\n\n    const getCallData$ = (arg: any, options: Partial<{ asset: any }> = {}) =>\n      compatibleRuntime$(chainHead, null).pipe(\n        map(([runtime]) => getCallDataWithContext(runtime, arg, options)),\n      )\n\n    const getEncodedData: TxCall = (\n      token?: CompatibilityToken | RuntimeToken,\n    ): any => {\n      if (!token)\n        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n      return getCallDataWithContext(token, arg).callData\n    }\n\n    const sign$ = (\n      from: PolkadotSigner,\n      { ..._options }: Omit<TxOptions<{}>, \"at\">,\n      atBlock: BlockInfo,\n    ) =>\n      getCallData$(arg, _options).pipe(\n        mergeMap(({ callData, options }) =>\n          createTx(\n            chainHead,\n            from,\n            callData.asBytes(),\n            atBlock,\n            _options.customSignedExtensions || {},\n            options,\n          ),\n        ),\n      )\n\n    const _sign = (\n      from: PolkadotSigner,\n      { at, ..._options }: TxOptions<{}> = {},\n    ) => {\n      return (\n        !at || at === \"finalized\"\n          ? chainHead.finalized$\n          : at === \"best\"\n            ? chainHead.best$\n            : chainHead.bestBlocks$.pipe(\n                map((x) => x.find((b) => b.hash === at)),\n              )\n      ).pipe(\n        take(1),\n        mergeMap((atBlock) =>\n          atBlock\n            ? sign$(from, _options, atBlock).pipe(\n                map((signed) => ({\n                  tx: toHex(signed),\n                  block: atBlock,\n                })),\n              )\n            : throwError(() => new Error(`Uknown block ${at}`)),\n        ),\n      )\n    }\n\n    const sign: TxSignFn<Asset> = (from, options) =>\n      firstValueFrom(_sign(from, options)).then((x) => x.tx)\n\n    const signAndSubmit: TxPromise<Asset> = (from, _options) =>\n      firstValueFrom(_sign(from, _options)).then(({ tx, block }) =>\n        submit(chainHead, broadcast, tx, block.hash),\n      )\n\n    const signSubmitAndWatch: TxObservable<Asset> = (from, _options) =>\n      _sign(from, _options).pipe(\n        mergeMap(({ tx }) => submit$(chainHead, broadcast, tx, true)),\n      )\n\n    const getPaymentInfo = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => {\n      if (typeof from === \"string\")\n        from = from.startsWith(\"0x\") ? fromHex(from) : accountIdEnc(from)\n      const isEth = from.length === 20\n      const fakeSigner = getPolkadotSigner(\n        from,\n        isEth ? \"Ecdsa\" : \"Sr25519\",\n        getFakeSignature(isEth),\n      )\n      const encoded = fromHex(await sign(fakeSigner, _options))\n      const args = toHex(mergeUint8([encoded, u32.enc(encoded.length)]))\n\n      const decoder$: Observable<Decoder<PaymentInfo>> = chainHead\n        .getRuntimeContext$(null)\n        .pipe(\n          map((ctx) => {\n            try {\n              return ctx.dynamicBuilder.buildRuntimeCall(\n                \"TransactionPaymentApi\",\n                \"query_info\",\n              ).value[1]\n            } catch {\n              return queryInfoDecFallback\n            }\n          }),\n        )\n\n      const call$ = chainHead.call$(\n        null,\n        \"TransactionPaymentApi_query_info\",\n        args,\n      )\n\n      return firstValueFrom(\n        combineLatest([call$, decoder$]).pipe(\n          map(([result, decoder]) => decoder(result)),\n        ),\n      )\n    }\n\n    const getEstimatedFees = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => (await getPaymentInfo(from, _options)).partial_fee\n\n    return {\n      getPaymentInfo,\n      getEstimatedFees,\n      decodedCall: {\n        type: pallet,\n        value: Enum(name, arg as any),\n      },\n      getEncodedData,\n      sign,\n      signSubmitAndWatch,\n      signAndSubmit,\n    }\n  }\n\n  return Object.assign(fn, {\n    getCompatibilityLevel,\n    isCompatible: isCompatibleHelper,\n  })\n}\n"],"names":["arg"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1299, "column": 0}, "map": {"version":3,"file":"self-dependent.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/utils/self-dependent.ts"],"sourcesContent":["import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies.\n *\n * @returns\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n"],"names":[],"mappings":";;;;;;;;;AAcO,MAAM,gBAAgB,MAGxB;IACH,MAAM,gBAA6C,4NAAI,kBAAA,CACrD,oNAAI,UAAW;IAEV,OAAA;QACL,aAAA,CAAc,IAAK,CAAA,+OAAA,EAAW,CAAA;QAC9B,iOACE,MAAA,AAAI,EAAA;gBACF,MAAM,CAAC,CAAA,GAAM,aAAc,CAAA,KAAA,CAAM,IAAA,CAAK,CAAC,CAAA;gBACvC,KAAA,EAAO,CAAC,CAAM,KAAA;oBACE,aAAA,CAAA,KAAA,CAAM,KAAA,CAAM,CAAC,CAAA;oBACb,aAAA,CAAA,IAAA,CAAK,oNAAI,UAAA,EAAY,CAAA;gBAAA,CACrC;gBACA,UAAU,MAAM;oBACd,aAAA,CAAc,KAAA,CAAM,QAAS,EAAA;oBACf,aAAA,CAAA,IAAA,CAAK,oNAAI,UAAA,EAAY,CAAA;gBAAA;YACrC,CACD;KACL;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1333, "column": 0}, "map": {"version":3,"file":"watch-entries.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/watch-entries.ts"],"sourcesContent":["import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  PinnedBlocks,\n  BlockInfo,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport {\n  BlockNotPinnedError,\n  isBestOrFinalizedBlock,\n} from \"@polkadot-api/observable-client\"\nimport {\n  catchError,\n  combineLatest,\n  delay,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  take,\n  takeUntil,\n  throwError,\n  withLatestFrom,\n} from \"rxjs\"\nimport { selfDependent, lossLessExhaustMap } from \"@/utils\"\nimport { state } from \"@rx-state/core\"\n\ninterface StorageEntry {\n  key: HexString\n  value: HexString\n  dec: {\n    args: Array<any>\n    value: any\n  }\n}\n\ntype Deltas = {\n  upserted: Array<StorageEntry>\n  deleted: Array<StorageEntry>\n}\n\ninterface MemoryBlock {\n  prev: HexString | null\n  block: BlockInfo\n  rootHash: string\n  entries: Array<StorageEntry>\n  deltas: Deltas | null\n}\n\ntype MemoryBlocks = {\n  blocks: Record<HexString, MemoryBlock>\n  finalized: HexString\n}\n\nconst getDiff = (\n  _prev: Array<StorageEntry>,\n  _current: Array<StorageEntry>,\n  patch: (input: StorageEntry) => StorageEntry,\n): Pick<MemoryBlock, \"entries\" | \"deltas\"> => {\n  const current = new Map(_current.map((x) => [x.key, x]))\n  const prev = new Map(_prev.map((x) => [x.key, x]))\n\n  const upserted: Map<string, StorageEntry> = new Map()\n  const deleted: Array<StorageEntry> = []\n\n  _current.forEach((value) => {\n    const { key } = value\n    const prevVal = prev.get(key)\n    if (!prevVal || prevVal.value !== value.value)\n      upserted.set(key, patch(value))\n  })\n\n  _prev.forEach((x) => {\n    if (!current.has(x.key)) deleted.push(x)\n  })\n\n  return {\n    deltas: {\n      deleted,\n      upserted: [...upserted.values()],\n    },\n    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key)!),\n  }\n}\n\nconst findPrevious = (\n  start: HexString,\n  state: MemoryBlocks[\"blocks\"],\n  pinned: PinnedBlocks,\n  includeStart = false,\n) => {\n  try {\n    let target = includeStart ? start : pinned.blocks.get(start)!.parent\n    while (target && !state[target]) target = pinned.blocks.get(target)!.parent!\n\n    if (!target) return null\n    return state[target]\n  } catch {\n    return null\n  }\n}\n\nconst getPatcherFromRuntime =\n  (pallet: string, entry: string) => (runtime: RuntimeContext) => {\n    const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry)\n    return (x: StorageEntry) => {\n      x.dec = {\n        value: value.dec(x.value),\n        args: keys.dec(x.key),\n      }\n      return x\n    }\n  }\n\nexport const createWatchEntries = (\n  blocks$: Observable<PinnedBlocks>,\n  storage: ChainHead$[\"storage$\"],\n  withRuntime: ChainHead$[\"withRuntime\"],\n) => {\n  const getMemoryBlocks$ = state(\n    (pallet: string, entry: string, storageKey: string) => {\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n      const getNextMemoryBlock$ = (\n        prev: MemoryBlock | null,\n        block: BlockInfo,\n      ): Observable<MemoryBlock> => {\n        const isNotCanonical$ = isBestOrFinalizedBlock(\n          blocks$,\n          block.hash,\n        ).pipe(\n          filter((x) => !x),\n          take(1),\n        )\n\n        return storage(\n          block.hash,\n          \"closestDescendantMerkleValue\",\n          () => storageKey,\n        ).pipe(\n          mergeMap((rootHash) => {\n            if (rootHash === prev?.rootHash)\n              return of({\n                ...prev,\n                block,\n                deltas: null,\n                prev: prev.block.hash,\n              })\n\n            return storage(\n              block.hash,\n              \"descendantsValues\",\n              () => storageKey,\n            ).pipe(\n              withRuntime(() => block.hash),\n              map(\n                ([entries, runtimeCtx]) =>\n                  [entries, getPatcher(runtimeCtx)] as const,\n              ),\n              map(\n                ([entries, patcher]): MemoryBlock => ({\n                  prev: prev && prev.block.hash,\n                  rootHash: rootHash!,\n                  block,\n                  ...getDiff(\n                    prev?.entries ?? [],\n                    entries as StorageEntry[],\n                    patcher,\n                  ),\n                }),\n              ),\n            )\n          }),\n          takeUntil(isNotCanonical$),\n          catchError((e) =>\n            e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e),\n          ),\n        )\n      }\n\n      const initial$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.finalized === b.finalized),\n        lossLessExhaustMap(({ blocks, finalized }) =>\n          getNextMemoryBlock$(null, blocks.get(finalized)!),\n        ),\n        take(1),\n        map(\n          (x): MemoryBlocks => ({\n            blocks: { [x.block.hash]: x },\n            finalized: x.block.hash,\n          }),\n        ),\n      )\n\n      const [_memoryBlocks$, connectMemoryBlocks] =\n        selfDependent<MemoryBlocks>()\n      const updates$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.best === b.best),\n        withLatestFrom(_memoryBlocks$),\n        lossLessExhaustMap(([pinned, memoryBlocks]) => {\n          const { best } = pinned\n          const { blocks } = memoryBlocks\n          let target = !blocks[best] ? best : null\n          if (!target) return EMPTY\n\n          const previous = findPrevious(target, blocks, pinned)\n          if (previous)\n            return getNextMemoryBlock$(\n              previous,\n              pinned.blocks.get(target)!,\n            ).pipe(\n              map((x) => {\n                blocks[target!] = x\n                return memoryBlocks\n              }),\n            )\n\n          // This means that there has been a stop event that the pinned-blocks\n          // couldn't recover from. Therefore, we must \"start over\"\n          target = pinned.finalized\n          return getNextMemoryBlock$(\n            blocks[memoryBlocks.finalized],\n            pinned.blocks.get(target)!,\n          ).pipe(\n            map((x) => {\n              x.prev = null\n              return {\n                blocks: { [target]: x },\n                finalized: target,\n              }\n            }),\n          )\n        }),\n      )\n\n      return merge(initial$, updates$).pipe(connectMemoryBlocks())\n    },\n  )\n\n  const getBestOrFinalized =\n    (isFinalized: boolean) =>\n    (pallet: string, entry: string, storageKey: string) => {\n      const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey)\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n\n      const prop = isFinalized ? \"finalized\" : \"best\"\n\n      return combineLatest([\n        memoryBlocks$.pipe(delay(0)),\n        blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop])),\n      ]).pipe(\n        map(([state, blocks]) =>\n          findPrevious(blocks[prop], state.blocks, blocks, true),\n        ),\n        filter(Boolean),\n        distinctUntilChanged(),\n        startWith(null),\n        pairwise(),\n        withLatestFrom(memoryBlocks$),\n        withRuntime(([[, _latest]]) => _latest!.block.hash),\n        map(\n          ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) =>\n            [\n              prevUpdate,\n              latest!,\n              memoryBlocks,\n              getPatcher(runtimeCtx),\n            ] as const,\n        ),\n        mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {\n          if (!prevUpdate) return [latest]\n\n          let ancestor: MemoryBlock | null = latest\n          const updates: Array<MemoryBlock> = []\n          while (ancestor && ancestor.block.number > prevUpdate.block.number) {\n            updates.unshift(ancestor)\n            ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null\n          }\n\n          if (isFinalized) {\n            memoryBlocks.finalized = latest.block.hash\n            if (updates.length) {\n              const { blocks } = memoryBlocks\n              Object.keys(blocks).forEach((key) => {\n                if (blocks[key].block.number < updates[0].block.number)\n                  delete blocks[key]\n              })\n            }\n          }\n\n          if (prevUpdate === ancestor) return updates\n\n          // It's a re-org\n          return [\n            {\n              ...latest,\n              ...(prevUpdate.rootHash === latest.rootHash\n                ? {\n                    entries: prevUpdate.entries,\n                    deltas: null,\n                  }\n                : getDiff(prevUpdate.entries, latest.entries, patcher)),\n            },\n          ]\n        }),\n      )\n    }\n\n  const getFinalized$ = state(getBestOrFinalized(true))\n  const getBest$ = state(getBestOrFinalized(false))\n\n  return (pallet: string, entry: string, args: Array<any>, atBest: boolean) => {\n    const fn = atBest ? getBest$ : getFinalized$\n    const storageKey$ = blocks$.pipe(\n      take(1),\n      mergeMap(\n        (b) =>\n          b.runtimes[b.blocks.get(b[atBest ? \"best\" : \"finalized\"])!.runtime]\n            .runtime,\n      ),\n      map((runtime) =>\n        runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args),\n      ),\n    )\n    return storageKey$.pipe(\n      take(1),\n      mergeMap((storageKey) => fn(pallet, entry, storageKey)),\n      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {\n        const actualDeltas =\n          idx > 0 ? deltas : { deleted: [], upserted: entries }\n\n        return {\n          block: { hash, number, parent },\n          entries: entries.map(toDec),\n          deltas: actualDeltas && {\n            deleted: actualDeltas.deleted.map(toDec),\n            upserted: actualDeltas.upserted.map(toDec),\n          },\n        }\n      }),\n    )\n  }\n}\n\nconst toDec = <T>(x: { dec: T }): T => x.dec\n"],"names":["state"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1543, "column": 0}, "map": {"version":3,"file":"viewFns.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/viewFns.ts"],"sourcesContent":["import { firstValueFromWithSignal, isOptionalArg } from \"@/utils\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { compactNumber, _void } from \"@polkadot-api/substrate-bindings\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport type ViewFn<Unsafe, D, Args extends Array<any>, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the view function.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nconst RUNTIME_NAMESPACE = \"RuntimeViewFunction\"\nconst RUNTIME_METHOD = \"execute_view_function\"\nconst RUNTIME_CALL_NAME = RUNTIME_NAMESPACE + \"_\" + RUNTIME_METHOD\n\nexport const createViewFnEntry = (\n  pallet: string,\n  entry: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): ViewFn<any, any, any, any> => {\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry ViewFn(${pallet}.${entry})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at).pipe(\n      mergeMap(([runtime, ctx]) => {\n        let apiCodec\n        try {\n          apiCodec = ctx.dynamicBuilder.buildRuntimeCall(\n            RUNTIME_NAMESPACE,\n            RUNTIME_METHOD,\n          )\n        } catch {\n          throw new Error(\n            `Runtime entry RuntimeCall(${RUNTIME_CALL_NAME}) not found`,\n          )\n        }\n        let viewCodec\n        try {\n          viewCodec = ctx.dynamicBuilder.buildViewFn(pallet, entry)\n        } catch {\n          throw new Error(`Runtime entry ViewFn(${pallet}.${entry}) not found`)\n        }\n        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError()\n        const viewArgs = viewCodec.args.enc(args)\n        const arg = mergeUint8([\n          fromHex(\n            ctx.lookup.metadata.pallets\n              .find(({ name }) => name === pallet)!\n              .viewFns.find(({ name }) => name === entry)!.id,\n          ),\n          compactNumber.enc(viewArgs.length),\n          viewArgs,\n        ])\n\n        return chainHead.call$(at, RUNTIME_CALL_NAME, toHex(arg)).pipe(\n          map((v) => {\n            try {\n              const decoded = apiCodec.value.dec(v)\n              if (\n                !(\"success\" in decoded && \"value\" in decoded) ||\n                (!(\"type\" in decoded.value) && !(\"asBytes\" in decoded.value))\n              )\n                throw null\n              return decoded\n            } catch {\n              throw new Error(\n                `Unexpected RuntimeCall(${RUNTIME_CALL_NAME}) type`,\n              )\n            }\n          }),\n          map(({ success, value }) => {\n            if (!success) throw new Error(`ViewFn API Error: ${value.type}`)\n            const decoded = viewCodec.value.dec(value.asBytes())\n            if (!valuesAreCompatible(runtime, ctx, decoded))\n              throw compatibilityError()\n            return decoded\n          }),\n        )\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { getCompatibilityLevel, isCompatible })\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1621, "column": 0}, "map": {"version":3,"file":"client.mjs","sources":["file:///Users/no/code/registry-template-v4/node_modules/.pnpm/polkadot-api%401.14.1_jiti%402.4.2_postcss%408.5.6_rxjs%407.8.2/node_modules/polkadot-api/src/client.ts"],"sourcesContent":["import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport {\n  enumValueEntryPointNode,\n  runtimeCallEntryPoint,\n  singleValueEntryPoint,\n  storageEntryPoint,\n  voidEntryPointNode,\n} from \"@polkadot-api/metadata-compatibility\"\nimport {\n  ChainHead$,\n  RuntimeContext,\n  getObservableClient,\n  withArchive,\n} from \"@polkadot-api/observable-client\"\nimport { Binary, HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  catchError,\n  defer,\n  firstValueFrom,\n  from,\n  map,\n  shareReplay,\n} from \"rxjs\"\nimport {\n  CompatibilityToken,\n  OpType,\n  RuntimeToken,\n  compatibilityHelper,\n  createCompatibilityToken,\n  createRuntimeToken,\n  getCompatibilityApi,\n} from \"./compatibility\"\nimport { createConstantEntry } from \"./constants\"\nimport { ChainDefinition } from \"./descriptors\"\nimport { createEventEntry } from \"./event\"\nimport { createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry } from \"./storage\"\nimport { createTxEntry, submit, submit$ } from \"./tx\"\nimport type { AnyApi, PolkadotClient } from \"./types\"\nimport { createWatchEntries } from \"./watch-entries\"\nimport { createViewFnEntry } from \"./viewFns\"\n\nconst createApi = <Unsafe extends true | false, D>(\n  compatibilityToken: Promise<CompatibilityToken | RuntimeToken>,\n  chainHead: ChainHead$,\n  broadcast$: (tx: string) => Observable<never>,\n): AnyApi<Unsafe, D> => {\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const getPallet = (ctx: RuntimeContext, name: string) =>\n    ctx.lookup.metadata.pallets.find((p) => p.name === name)\n\n  const getWatchEntries = createWatchEntries(\n    chainHead.pinnedBlocks$,\n    chainHead.storage$,\n    chainHead.withRuntime,\n  )\n  const query = createProxyPath((pallet, name) =>\n    createStorageEntry(\n      pallet,\n      name,\n      chainHead,\n      getWatchEntries,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Storage, pallet, name),\n        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.storage?.items.find(\n            (s) => s.name === name,\n          )\n          return item == null ? null : storageEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const getEnumEntry = (\n    ctx: RuntimeContext,\n    side: \"args\" | \"values\",\n    id: number | undefined,\n    name: string,\n  ) => {\n    if (id == null) return null\n    const entry = ctx.lookup(id)\n    if (entry.type !== \"enum\") throw new Error(\"Expected enum\")\n\n    if (entry.value[name] == null) return null\n    const node = enumValueEntryPointNode(entry.value[name])\n    return {\n      args: side === \"args\" ? node : voidEntryPointNode,\n      values: side === \"args\" ? voidEntryPointNode : node,\n    }\n  }\n  const tx = createProxyPath((pallet, name) =>\n    createTxEntry(\n      pallet,\n      name,\n      chainHead,\n      broadcast$,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Tx, pallet, name),\n        (ctx) =>\n          getEnumEntry(ctx, \"args\", getPallet(ctx, pallet)?.calls?.type, name),\n      ),\n      true,\n    ),\n  )\n\n  const event = createProxyPath((pallet, name) =>\n    createEventEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Event, pallet, name),\n        (ctx) =>\n          getEnumEntry(\n            ctx,\n            \"values\",\n            getPallet(ctx, pallet)?.events?.type,\n            name,\n          ),\n      ),\n    ),\n  )\n\n  const constants = createProxyPath((pallet, name) =>\n    createConstantEntry(\n      pallet,\n      name,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Const, pallet, name),\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.constants.find(\n            (c) => c.name === name,\n          )?.type\n          return item == null ? null : singleValueEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const apis = createProxyPath((api, method) =>\n    createRuntimeCallEntry(\n      api,\n      method,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.Api, api, method),\n        (ctx) =>\n          runtimeCallEntryPoint(\n            ctx.lookup.metadata.apis\n              .find((a) => a.name === api)!\n              .methods.find((m) => m.name === method)!,\n          ),\n      ),\n    ),\n  )\n  const view = createProxyPath((pallet, entry) =>\n    createViewFnEntry(\n      pallet,\n      entry,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getEntryPoint(OpType.ViewFns, pallet, entry),\n        (ctx) =>\n          runtimeCallEntryPoint(\n            ctx.lookup.metadata.pallets\n              .find((a) => a.name === pallet)!\n              .viewFns.find((m) => m.name === entry)!,\n          ),\n      ),\n    ),\n  )\n\n  const _callDataTx = (\n    callData: Binary,\n    token: CompatibilityToken | RuntimeToken,\n  ) => {\n    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime()\n    try {\n      const decoded = dynamicBuilder\n        .buildDefinition(lookup.call!)\n        .dec(callData.asBytes())\n      const pallet = decoded.type\n      const call = decoded.value.type\n      const args = decoded.value.value\n\n      return createTxEntry(\n        pallet,\n        call,\n        chainHead,\n        broadcast$,\n        compatibilityHelper(\n          compatibilityToken,\n          (r) => r.getEntryPoint(OpType.Tx, pallet, call),\n          (ctx) =>\n            getEnumEntry(\n              ctx,\n              \"args\",\n              getPallet(ctx, pallet)?.calls?.type,\n              call,\n            ),\n        ),\n        false,\n      )(args)\n    } catch {\n      throw new Error(\"createTx: invalid call data\")\n    }\n  }\n\n  return {\n    query,\n    txFromCallData: (\n      callData: Binary,\n      token?: CompatibilityToken | RuntimeToken,\n    ) =>\n      token\n        ? _callDataTx(callData, token)\n        : compatibilityToken.then((t) => _callDataTx(callData, t)),\n    tx,\n    event,\n    apis,\n    constants,\n    view,\n  } as any\n}\n\nexport type CreateClientOptions = Partial<{\n  getMetadata: (codeHash: HexString) => Promise<Uint8Array | null>\n  setMetadata: (codeHash: HexString, metadata: Uint8Array) => void\n}>\n\n/**\n * This is the top-level export for `polkadot-api`.\n *\n * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC\n *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),\n *                  which must support the `chainHead`, `transaction` and\n *                  `chainSpec` groups.\n * @param options   - *(Optional)* An object that allows customization of\n *                  metadata handling.\n *                  You can supply functions to retrieve and/or persist the\n *                  metadata associated with runtime `codeHash` values:\n *\n *                  - `getMetadata`: A function that, given a `codeHash` (the\n *                  `:code:` hash),\n *                  returns a `Promise` resolving to a `Uint8Array`\n *                  representing the metadata,\n *                  or `null` if unavailable.\n *                  - `setMetadata`: A function that accepts a `codeHash` and\n *                  its associated `Uint8Array` metadata,\n *                  allowing you to persist the metadata (e.g., in a cache or\n *                  local store).\n * @example\n *\n *   import { getMetadata } from \"@polkadot-api/descriptors\"\n *   import { createClient } from \"polkadot-api\"\n *   import { getSmProvider } from \"polkadot-api/sm-provider\"\n *   import { chainSpec } from \"polkadot-api/chains/polkadot\"\n *   import { start } from \"polkadot-api/smoldot\"\n *\n *   const smoldot = start()\n *   const chain = await smoldot.addChain({ chainSpec })\n *\n *   // Connect to the polkadot relay chain.\n *   const client = createClient(getSmProvider(chain), { getMetadata })\n *\n */\nexport function createClient(\n  provider: JsonRpcProvider,\n  { getMetadata, setMetadata }: CreateClientOptions = {},\n): PolkadotClient {\n  const rawClient: SubstrateClient = createRawClient(provider)\n  const client = getObservableClient(rawClient, {\n    getMetadata: getMetadata\n      ? (codeHash: string) => from(getMetadata(codeHash))\n      : undefined,\n    setMetadata,\n  })\n  const { getChainSpecData } = rawClient\n\n  const { genesis$, ..._chainHead } = client.chainHead$()\n  const archive = client.archive(_chainHead.getRuntime$)\n  const chainHead: ChainHead$ = {\n    ..._chainHead,\n    genesis$: defer(getChainSpecData).pipe(\n      map(({ genesisHash }) => genesisHash),\n      catchError(() => genesis$),\n      shareReplay(1),\n    ),\n    storage$: withArchive(_chainHead.storage$, archive.storage$),\n    body$: withArchive(_chainHead.body$, archive.body$),\n    call$: withArchive(_chainHead.call$, archive.call$),\n    header$: withArchive(_chainHead.header$, archive.header$),\n    eventsAt$: withArchive(_chainHead.eventsAt$, archive.eventsAt$),\n    storageQueries$: withArchive(\n      _chainHead.storageQueries$,\n      archive.storageQueries$,\n    ),\n    getRuntimeContext$: withArchive(\n      _chainHead.getRuntimeContext$,\n      archive.getRuntimeContext$,\n    ),\n  }\n\n  const _request: <Reply = any, Params extends Array<any> = any[]>(\n    method: string,\n    params: Params,\n  ) => Promise<Reply> = rawClient.request\n\n  let runtimeToken: Promise<RuntimeToken>\n  const compatibilityToken = new WeakMap<\n    ChainDefinition,\n    Promise<CompatibilityToken<any>>\n  >()\n  const getChainToken = (chainDefinition: ChainDefinition) => {\n    const result =\n      compatibilityToken.get(chainDefinition) ||\n      createCompatibilityToken(chainDefinition, chainHead)\n    compatibilityToken.set(chainDefinition, result)\n    return result\n  }\n  const getRuntimeToken = <D>(): Promise<RuntimeToken<D>> =>\n    (runtimeToken ??= createRuntimeToken(chainHead))\n  const { broadcastTx$ } = client\n\n  return {\n    getChainSpecData,\n\n    blocks$: chainHead.newBlocks$,\n\n    finalizedBlock$: chainHead.finalized$,\n    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),\n\n    bestBlocks$: chainHead.bestBlocks$,\n    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),\n\n    watchBlockBody: chainHead.body$,\n    getBlockBody: (hash: string) => firstValueFrom(chainHead.body$(hash)),\n\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n\n    submit: (...args) => submit(chainHead, broadcastTx$, ...args),\n    submitAndWatch: (tx) => submit$(chainHead, broadcastTx$, tx),\n\n    getTypedApi: <D extends ChainDefinition>(chainDefinition: D) => {\n      const token = getChainToken(chainDefinition)\n      return Object.assign(\n        createApi<false, D>(token, chainHead, broadcastTx$),\n        { compatibilityToken: token },\n      )\n    },\n\n    getUnsafeApi: <D>() => {\n      const token = getRuntimeToken()\n      return Object.assign(createApi<true, D>(token, chainHead, broadcastTx$), {\n        runtimeToken: token,\n      })\n    },\n\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n\n    _request,\n  }\n}\n"],"names":["createRawClient"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}