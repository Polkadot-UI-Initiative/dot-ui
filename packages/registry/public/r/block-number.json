{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "block-number",
  "type": "registry:component",
  "title": "Block Number",
  "description": "A simple block number component that displays the current block number from Polkadot Asset Hub. Requires polkadot-api setup or dedot.",
  "dependencies": [
    "polkadot-api",
    "dedot",
    "react-use"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "registry/polkadot-ui/blocks/block-number/components/block-number.tsx",
      "content": "\"use client\";\n\nimport { useBlockNumber } from \"@/registry/polkadot-ui/blocks/block-number/hooks/use-block-number\";\nimport { Button } from \"@/registry/polkadot-ui/ui/button\";\nimport { useDedot } from \"@/registry/polkadot-ui/providers/dedot-provider\";\n\nexport function BlockNumber() {\n  const { blockNumber, error } = useBlockNumber();\n  // Using PolkadotProvider\n  // const {\n  //   setApi,\n  //   availableChains,\n  //   isConnected,\n  //   isLoading: isLoading,\n  //   currentChain,\n  //   chainName,\n  // } = usePolkadot();\n\n  // using DedotProvider\n  const {\n    setApi,\n    availableChains,\n    isConnected,\n    isLoading: isLoadingDedot,\n    isLoading,\n    currentChain,\n    chainName,\n  } = useDedot();\n\n  if (isLoadingDedot) {\n    return (\n      <div className=\"w-full max-w-md p-4 borderrounded-md\">\n        <div className=\"mb-4\">\n          <h3 className=\"text-lg font-semibold\">Block Number</h3>\n          <p className=\"text-sm text-gray-600\">Loading...</p>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600\"></div>\n          <span className=\"text-sm text-gray-600\">\n            Connecting to {chainName}...\n          </span>\n        </div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"w-full max-w-md p-4 border border-error rounded-md bg-error\">\n        <div className=\"mb-4\">\n          <h3 className=\"text-lg font-semibold text-error\">Block Number</h3>\n          <p className=\"text-sm text-error\">Error loading block number</p>\n        </div>\n        <div className=\"text-error text-sm\">{error}</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"w-full max-w-md rounded-md\">\n      <div className=\"space-y-4\">\n        <div className=\"text-3xl font-bold text-polkadot-pink\">\n          {blockNumber?.toLocaleString() || \"Loading...\"}\n        </div>\n\n        <div className=\"space-y-2\">\n          <div className=\"text-sm text-gray-600\">\n            Current chain: <span className=\"font-mono\">{chainName}</span>\n          </div>\n\n          <div className=\"flex gap-2 flex-wrap\">\n            {availableChains.map((chainId) => (\n              <Button\n                key={chainId}\n                variant={chainId === currentChain ? \"default\" : \"outline\"}\n                size=\"sm\"\n                onClick={() => setApi(chainId)}\n                disabled={isLoading}\n              >\n                {chainId}\n                {isConnected(chainId) && (\n                  <span className=\"ml-1 text-xs text-green-600\">‚óè</span>\n                )}\n              </Button>\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/polkadot-ui/blocks/block-number/hooks/use-block-number.ts",
      "content": "\"use client\";\nimport { useDedot } from \"@/registry/polkadot-ui/providers/dedot-provider\";\nimport { useEffect, useState } from \"react\";\n\nexport function useBlockNumber() {\n  // Use the new provider API without specifying a chain - it uses the currently active chain\n  // This is using PapiProvider\n  // const { api, isLoading, error: apiError, currentChain } = usePolkadot();\n\n  // Using DedotProvider\n  const { api, legacy, isLoading: isLoadingDedot, error: apiError, currentChain } = useDedot();\n  const [isLoadingBlock, setLoadingBlock] = useState(true);\n  const [blockNumber, setBlockNumber] = useState<number | null>(null);\n\n  useEffect(() => {\n    // Using PolkadotProvider\n    // if (!api || isLoading(currentChain)) return;\n\n    // // No type assertions needed - TypeScript knows the exact API structure!\n    // const subscription = api.query.System.Number.watchValue(\"best\").subscribe(\n    //   (value: number) => {\n    //     setBlockNumber(value);\n    //   }\n    // );\n\n    // return () => {\n    //   subscription?.unsubscribe();\n    // };\n\n    // Using DedotProvider\n    let unsubscribe: any;\n       \n    (async () => {\n     const client = api || legacy;\n     if (!client) {\n         return;\n     }\n     \n     setLoadingBlock(true);\n\n     unsubscribe = await client.query.system.number((blockNumber: number) => {   \n         setBlockNumber(blockNumber);\n         setLoadingBlock(false);\n     });\n    })();\n\n     return () => {\n         unsubscribe && unsubscribe();\n     };\n  }, [api, isLoadingDedot, currentChain, legacy]);\n\n  return {\n    blockNumber,\n    isLoadingDedot,\n    isLoadingBlock,\n    error: apiError,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/polkadot-ui/providers/polkadot-provider.tsx",
      "content": "\"use client\";\n\nimport { createClient, TypedApi } from \"polkadot-api\";\nimport { getWsProvider } from \"polkadot-api/ws-provider/web\";\nimport { withPolkadotSdkCompat } from \"polkadot-api/polkadot-sdk-compat\";\nimport { createContext, useContext, useEffect, useState } from \"react\";\nimport {\n  polkadotConfig,\n  type ChainId,\n  type ChainDescriptor,\n} from \"@/registry/polkadot-ui/lib/config.polkadot-ui\";\nimport {\n  getChainIds,\n  getChainConfig,\n  isValidChainId,\n} from \"@/registry/polkadot-ui/lib/utils.polkadot-ui\";\n\n// Type for the API based on configured chains\ntype ConfiguredChainApi<T extends ChainId> = TypedApi<ChainDescriptor<T>>;\n\n// Create a composite API type that includes all registered chains\ntype CompositeApi = {\n  [K in ChainId]: ConfiguredChainApi<K>;\n};\n\ninterface PolkadotContextValue {\n  // Current active chain and its API\n  currentChain: ChainId;\n  api: ConfiguredChainApi<ChainId> | null;\n  isLoading: (chainId: ChainId) => boolean;\n  error: string | null;\n\n  // All APIs for all registered chainsp\n  apis: Partial<CompositeApi>;\n\n  // Function to switch active chain (type-safe)\n  setApi: (chainId: ChainId) => void;\n\n  // Connection management\n  disconnect: () => void;\n  isConnected: (chainId: ChainId) => boolean;\n\n  // Chain information\n  chainName: string | null;\n  availableChains: ChainId[];\n}\n\nconst PolkadotContext = createContext<PolkadotContextValue | undefined>(\n  undefined\n);\n\ninterface PolkadotProviderProps {\n  children: React.ReactNode;\n}\n\nexport function PolkadotProvider({ children }: PolkadotProviderProps) {\n  const [currentChain, setCurrentChain] = useState<ChainId>(\n    polkadotConfig.defaultChain\n  );\n  const [apis, setApis] = useState<Partial<CompositeApi>>({});\n  const [clients, setClients] = useState<\n    Map<ChainId, ReturnType<typeof createClient>>\n  >(new Map());\n  const [loadingStates, setLoadingStates] = useState<Map<ChainId, boolean>>(\n    new Map()\n  );\n  const [errorStates, setErrorStates] = useState<Map<ChainId, string | null>>(\n    new Map()\n  );\n\n  // Initialize the default chain on mount\n  useEffect(() => {\n    initializeChain(polkadotConfig.defaultChain);\n  }, []);\n\n  const initializeChain = async (chainId: ChainId) => {\n    // Don't initialize if already connected\n    if (apis[chainId]) return;\n\n    setLoadingStates((prev) => new Map(prev).set(chainId, true));\n    setErrorStates((prev) => new Map(prev).set(chainId, null));\n\n    try {\n      const chainConfig = getChainConfig(polkadotConfig.chains, chainId);\n\n      console.log(\n        `Connecting to ${chainConfig.displayName} at ${chainConfig.endpoints[0]}`\n      );\n\n      // Create client with the selected chain\n      const client = createClient(\n        withPolkadotSdkCompat(getWsProvider(chainConfig.endpoints[0]))\n      );\n\n      // Get typed API for the selected chain\n      const typedApi = client.getTypedApi(\n        chainConfig.descriptor\n      ) as ConfiguredChainApi<typeof chainId>;\n\n      setClients((prev) => new Map(prev).set(chainId, client));\n      setApis((prev) => ({ ...prev, [chainId]: typedApi }));\n\n      console.log(`Successfully connected to ${chainConfig.displayName}`);\n    } catch (err) {\n      console.error(`Failed to initialize ${chainId}:`, err);\n      setErrorStates((prev) =>\n        new Map(prev).set(\n          chainId,\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize Polkadot API\"\n        )\n      );\n    } finally {\n      setLoadingStates((prev) => new Map(prev).set(chainId, false));\n    }\n  };\n\n  const setApi = (chainId: ChainId) => {\n    if (!isValidChainId(polkadotConfig.chains, chainId)) {\n      console.error(`Invalid chain ID: ${chainId}`);\n      return;\n    }\n\n    setCurrentChain(chainId);\n    // Initialize the chain if not already connected\n    if (!apis[chainId]) {\n      initializeChain(chainId);\n    }\n  };\n\n  const disconnect = () => {\n    clients.forEach((client) => client.destroy());\n    setClients(new Map());\n    setApis({});\n    setLoadingStates(new Map());\n    setErrorStates(new Map());\n    setCurrentChain(polkadotConfig.defaultChain);\n  };\n\n  const isConnected = (chainId: ChainId): boolean => {\n    return !!apis[chainId];\n  };\n\n  const isLoading = (chainId: ChainId): boolean => {\n    return loadingStates.get(chainId) || false;\n  };\n\n  const currentChainConfig = getChainConfig(\n    polkadotConfig.chains,\n    currentChain\n  );\n\n  const value: PolkadotContextValue = {\n    currentChain,\n    api: apis[currentChain] || null,\n    error: errorStates.get(currentChain) || null,\n    apis,\n    setApi,\n    disconnect,\n    isConnected,\n    isLoading,\n    chainName: currentChainConfig.displayName,\n    availableChains: getChainIds(polkadotConfig.chains),\n  };\n\n  return (\n    <PolkadotContext.Provider value={value}>\n      {children}\n    </PolkadotContext.Provider>\n  );\n}\n\nexport function usePolkadot(): PolkadotContextValue {\n  const context = useContext(PolkadotContext);\n\n  if (context === undefined) {\n    throw new Error(\"usePolkadot must be used within a PolkadotProvider\");\n  }\n\n  return context;\n}\n\n// Helper to get properly typed API (maintains backward compatibility)\nexport function useTypedPolkadotApi(): ConfiguredChainApi<ChainId> | null {\n  const { api } = usePolkadot();\n  return api;\n}\n\n// Type exports\nexport type { ChainId, ConfiguredChainApi, CompositeApi };\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/polkadot-ui/providers/dedot-provider.tsx",
      "content": "\"use client\"\n\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport { JsonRpcApi } from '@/registry/polkadot-ui/lib/types.polkadot-ui';\nimport { ChainId, polkadotConfig } from '@/registry/polkadot-ui/lib/config.polkadot-ui';\nimport { DedotClient, LegacyClient, WsProvider } from 'dedot';\nimport { PropsWithChildren } from 'react';\nimport { useLocalStorage, useAsync, useToggle } from 'react-use';\nimport { ChainConfig } from '@/registry/polkadot-ui/lib/types.polkadot-ui';\nimport { getChainConfig, getChainIds } from '@/registry/polkadot-ui/lib/utils.polkadot-ui';\n\ninterface DedotContextProps {\n  // Current active chain and its API\n  currentChain: ChainId;\n  api?: DedotClient | null;\n  legacy?: LegacyClient | null;\n  jsonRpc: JsonRpcApi;\n  apiReady: boolean;\n  isLoading: boolean;\n  error: string | null;\n\n  // API for switching active chain\n  setApi: (chainId: ChainId) => void;\n  \n  // API for connection management\n  disconnect: () => Promise<void>;\n  isConnected: (chainId: ChainId) => boolean;\n\n  // Chain info\n  chainName: string | null;\n  availableChains: ChainId[];\n}\n\nconst DedotContext = createContext<DedotContextProps | undefined>(undefined);\n\nexport default function DedotProvider({ children }: PropsWithChildren) {\n  const [chain, setChain] = useState<ChainConfig | undefined>();\n  const [currentChain, setCurrentChain] = useState<ChainId>(\n    polkadotConfig.defaultChain\n  );\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const availableChains = getChainIds(polkadotConfig.chains);\n  \n  const [jsonRpc] = useLocalStorage<JsonRpcApi>('SETTINGS/JSON_RPC_API', JsonRpcApi.NEW);\n  const [apiReady, setApiReady] = useToggle(false);\n  const [api, setApiClient] = useState<DedotClient>();\n  const [legacy, setLegacy] = useState<LegacyClient>();\n\n  const currentChainConfig = getChainConfig(\n    polkadotConfig.chains,\n    currentChain\n  );\n\n  useAsync(async () => {\n        if (!chain) {\n        return;\n        }\n\n        setIsLoading(true);\n        setError(null);\n\n        try {\n            if (api) {\n            await api.disconnect();\n            }\n\n            if (legacy) {\n            await legacy.disconnect();\n            }\n\n            setApiReady(false);\n\n            const provider = new WsProvider(chain.endpoints);\n            provider.on('connected', (endpoint: string) => {\n            console.log('Connected Endpoint', endpoint);\n            });\n\n            await provider.connect();\n\n            if (jsonRpc === JsonRpcApi.LEGACY) {\n            const legacyClient = await LegacyClient.new({ provider, cacheMetadata: true });\n            setLegacy(legacyClient);\n            setApiClient(undefined);\n            } else {\n            const apiClient = await DedotClient.new({ provider, cacheMetadata: true });\n            setApiClient(apiClient);\n            setLegacy(undefined);\n            }\n\n            setApiReady(true);\n        } catch (err) {\n            console.error(`Failed to initialize ${currentChain}:`, err);\n            setError(err instanceof Error ? err.message : \"Failed to initialize Polkadot API\");\n        } finally {\n            setIsLoading(false);\n        }\n    }, [jsonRpc, chain?.endpoints]);\n\n  useEffect(() => {\n    if (currentChain && availableChains.includes(currentChain)) {\n      setChain(getChainConfig(polkadotConfig.chains, currentChain));\n    }\n  }, [currentChain, availableChains]);\n\n  const isConnected = (chainId: ChainId) => {\n    return currentChain === chainId;\n  };\n\n  const disconnect = async () => {\n    if (api) {\n      await api.disconnect();\n    }\n    if (legacy) {\n      await legacy.disconnect();\n    }\n\n    setApiClient(undefined);\n    setLegacy(undefined);\n    setApiReady(false);\n\n    setCurrentChain(polkadotConfig.defaultChain);\n  };\n\n  const setApi = (chainId: ChainId) => {\n    setCurrentChain(chainId);\n  };\n\n  const value: DedotContextProps = {\n    currentChain,\n    api,\n    legacy,\n    setApi,\n    disconnect,\n    isConnected,\n    isLoading,\n    error: error || null,\n    jsonRpc: jsonRpc!,\n    apiReady,\n    chainName: currentChainConfig.displayName,\n    availableChains,\n  };\n\n  return (\n    <DedotContext.Provider value={value}>\n      {children}\n    </DedotContext.Provider>\n  );\n}\n\nexport function useDedot(): DedotContextProps {\n  const context = useContext(DedotContext);\n  if (!context) {\n    throw new Error('useDedotContext must be used within a DedotProvider');\n  }\n  return context;\n} ",
      "type": "registry:lib"
    },
    {
      "path": "registry/polkadot-ui/lib/utils.polkadot-ui.ts",
      "content": "import type { ChainConfig } from \"@/registry/polkadot-ui/lib/types.polkadot-ui\";\n\n// Generic helper functions that work with any polkadot config\nexport function getChainIds<T extends Record<string, ChainConfig>>(\n  chains: T\n): (keyof T)[] {\n  return Object.keys(chains) as (keyof T)[];\n}\n\nexport function getChainConfig<\n  T extends Record<string, ChainConfig>,\n  K extends keyof T\n>(chains: T, chainId: K): T[K] {\n  return chains[chainId];\n}\n\nexport function isValidChainId<T extends Record<string, ChainConfig>>(\n  chains: T,\n  chainId: string\n): chainId is string & keyof T {\n  return chainId in chains;\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/polkadot-ui/lib/types.polkadot-ui.ts",
      "content": "import type { ChainDefinition } from \"polkadot-api\";\n\n// interfaces related to papi\nexport interface ChainConfig {\n  readonly descriptor: ChainDefinition;\n  readonly network: string;\n  readonly endpoints: string[];\n  readonly displayName: string;\n  readonly isTestnet: boolean;\n  readonly icon?: string;\n  readonly explorerUrls?: Partial<Record<SubstrateExplorer, string>>;\n  readonly faucetUrls?: string[];\n}\n\nexport interface PolkadotConfig<\n  TChains extends Readonly<Record<string, ChainConfig>> = Readonly<\n    Record<string, ChainConfig>\n  >\n> {\n  readonly chains: TChains;\n  readonly defaultChain: keyof TChains;\n}\n\nexport function definePolkadotConfig<\n  const TChains extends Readonly<Record<string, ChainConfig>>\n>(config: PolkadotConfig<TChains>) {\n  return config;\n}\n\n// interfaces related to dedot\nexport enum SubstrateExplorer {\n  Subscan = 'subscan',\n  PolkadotJs = 'polkadot-js',\n  PapiExplorer = 'papi-explorer',\n}\n\nexport enum JsonRpcApi {\n  LEGACY = 'legacy',\n  NEW = 'new'\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/polkadot-ui/lib/config.polkadot-ui.ts",
      "content": "// To add more chains, run: npx papi add <chain-name> -n <chain-name>\n// Then import the descriptor here and add it to the chains configuration\nimport { paseo_asset_hub, paseo } from \"@polkadot-api/descriptors\";\nimport { definePolkadotConfig, SubstrateExplorer } from \"@/registry/polkadot-ui/lib/types.polkadot-ui\";\n\n// dedot supports multiple endpoints for automatic failover\n// while papi only supports one endpoint so users need to select one manually\nexport const polkadotConfig = definePolkadotConfig({\n  chains: {\n    paseo_asset_hub: {\n      descriptor: paseo_asset_hub,\n      network: \"paseo-asset-hub\",\n      endpoints: [\"wss://sys.ibp.network/asset-hub-paseo\", \"wss://asset-hub-paseo.dotters.network\"],\n      displayName: \"Paseo Asset Hub\",\n      explorerUrls: {\n        [SubstrateExplorer.PolkadotJs]: `https://polkadot.js.org/apps/?rpc=${encodeURIComponent('wss://sys.ibp.network/asset-hub-paseo')}#/explorer`,\n      },\n      isTestnet: true,\n    },\n    paseo: {\n      descriptor: paseo,\n      network: \"paseo\",\n      endpoints: [\"wss://sys.ibp.network/paseo\", \"wss://paseo.dotters.network\"],\n      displayName: \"Paseo Relay Chain\",\n      explorerUrls: {\n        [SubstrateExplorer.PolkadotJs]: `https://polkadot.js.org/apps/?rpc=${encodeURIComponent('wss://sys.ibp.network/paseo')}#/explorer`,\n      },\n      isTestnet: true,\n    },\n    // Add more chains here after running `npx papi add <chain-name>`\n    // Example for adding Polkadot mainnet:\n    // 1. Run: npx papi add polkadot -n polkadot\n    // 2. Import: import { polkadot } from \"@polkadot-api/descriptors\";\n    // 3. Add configuration:\n    // polkadot: {\n    //   descriptor: polkadot,\n    //   network: \"polkadot\",\n    //   endpoints: [\"wss://polkadot-rpc.publicnode.com\"],\n    //   displayName: \"Polkadot\",\n    // },\n  },\n  defaultChain: \"paseo_asset_hub\",\n} as const);\n\n// Simple type aliases for type safety\nexport type ChainId = keyof typeof polkadotConfig.chains;\nexport type ChainDescriptor<T extends ChainId> =\n  (typeof polkadotConfig.chains)[T][\"descriptor\"];\nexport type ChainNetwork<T extends ChainId> = typeof polkadotConfig.chains[T]['network']\n",
      "type": "registry:lib"
    }
  ]
}